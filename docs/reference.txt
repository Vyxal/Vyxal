cmd     stack   out/*effect
!              |len(stack)
"              |* rotate entire stack right
$       a,b    |b,a
%       a,b    |a % b
&       a      |* register = a
'              |* rotate entire stack left
(              |* open a for loop: (variable|code)
)              |* close a for loop
*       a,b    |a * b
+       a,b    |a + b
,       a      |print(a)
-       a,b    |a - b
.       a      |print(vyrepr(a))
/       a,b    |a / b
0              |* integer literal
1              |* integer literal
2              |* integer literal
3              |* integer literal
4              |* integer literal
5              |* integer literal
6              |* integer literal
7              |* integer literal
8              |* integer literal
9              |* integer literal
:       a      |a,a
;              |* end a structure
<       a,b    |a < b
=       a,b    |a == b (non-vectorising)
>       a,b    |a > b
?              |* take input from either cmd line or stdin, whichever is first
@              |* define / call a function
A       a      |all(a)
B       a      |int(a, 2) # binary to base 10
C       a      |chr(a) if a is int/ord(a) is a is chr
D       a      |a,a,a
E       a      |eval(a)
F       a,f    |a with elements that give truthy results when f is applied
G       a      |max(a) # max of iterable
H       a      |int(a, 16) # hex to decimal
I       a      |int(a)
J       a,b    |concat(a, b)
K              |factors_of(a)
L       a      |len(a)
M       a,f    |f mapped to each element in a
N       a      |number(a)
O       a,b    |a.count(b)
P       a,b    |a.strip(b)
Q              |* end execution (exit())
R       a,f    |reduce a by function f
S       a      |str(a)
T       a      |[_ for _ in a if bool(_)]
U       a      |uniquify(a)
V       a,b,c  |a.replace()
W              |* wrap the entire stack into a single list
X              |* context level up
Y       a,b    |interleave(x, y)
Z       a,b    |zip(x, y)
[              |* if statement
\              |* one char string
]              |* close if statement
`              |* string delimiter
a       a      |any(a)
b       a      |bin(a) #base 10 to binary
c       a,b    |a in b (non-vectorising)
d       a      |a * 2
e       a,b    |a ^ b (exponation)
f       a      |flattened(a)
g       a      |min(a) # min of iterable
h       a      |a[0]
i       a,b    |a[b]
j       a,b    |a.join(b)
k       a      |* push the constant at the next char k<char>
l              |[]
m       a      |a + a[::-1]
n              |* contextual variable
o       a,b    |a.replace(b, '') # same as a bâV
p       a,b    |a.startswith(b)
q       a      |"`" + a + "`"
r       a,b    |range(a, b)
s       a      |sorted(a)
t       a      |a[-1]
u       a      |sorted(uniquified(a)) #same as US (lol)
v              |* vectorise the next command
w       a      |[a]
x              |* context level down
y       a      |uninterleave(a)
z       a,f    |zipmap the contents of a with function f
{              |* open while loop
|              |* structure branch
}              |* close while loop
~              |random.randint(-INT, INT)
Î»              |* start a lambda
Æ›              |* start a mapping lambda
Â¬       a      |not a
âˆ§       a,b    |a and b (logical)
âŸ‘       a,b    |a and b (short-circuited)
âˆ¨       a,b    |a or b (logical)
âŸ‡       a,b    |a or b (short-circuited)
Ã·       a      |item_split(a)
Â«              |* base 255 string
Â»              |* base 255 number
Â°              |* function reference
â€¢              |* decimal separator
â€¤              |* function reference of a built-in
â       a      |* call function a
á¹š       a,b    |random.randint(a,b)
Â½       a      |a / 2
âˆ†              |* two byte math functions
Ã¸              |* two byte string functions
Ã       a,b    |a.index(b)
Ã”              |list of positive odd numbers
Ã‡       a      |1 - a
Ã¦       a      |is_prime(a)
Ê€       a      |range(0, a + 1)
Ê       a      |range(0, a)
É¾       a      |range(1, a + 1)
É½       a      |range(1, a)
Ã              |* two byte list functions
Æˆ       a,b    |ncr(a, b)
âˆ              |infinite list of positive integers (0 included)
â«™              |* two byte misc functions
ÃŸ       a      |[bin(_) for _ in a]
â       a      |min(a, key=lambda x: x[-1])
â        a      |max(a, key=lambda x: x[-1])
â¡       a,b    |max(a, b)
â£       a,b    |min(a, b)
â¨¥       a      |a + 1
â¨ª       a      |a - 1
âˆº       a      |a % 2
â              |""
Ã°              |" "
â†’       a      |* variable = a
â†              |variable
Ã       a,b    |to_base_ten(a, b) #a_b => base 10
Å™       a,b    |repeat(a, b)
Å        a,b    |from_base_ten(a, b) #a_10 => base_b
Ä       a      |a != 1
âˆš       a      |sqrt(a)
â³¹       a,b    |a // b
áºŠ       a,b    |a xor b
È¦       a      |abs(a)
È®       a      |oct(a)
á¸Š       a,b    |divmod(a, b)
Ä–       a      |enumerate(a)
áº¸              |enumerate(stack)
á¹™       a      |round(a)
âˆ‘       a      |sum(a)
á¹        a      |sum of stack
Ä°       a      |id(x)
Ä¤       a      |100
âŸ¨              |* open a list âŸ¨âŸ©âŸ¨...|...âŸ©
âŸ©              |* close a list
Ä±              |* 2 char compressed string
âŒ       a      |'\n'.join(a)
Î¤              |10
Ä´       a      |''.join(a)
Â²       a      |a ^ 2
â€¿       a,b    |[a, b]
â‚       a,b    |inclusive_range(a, b)
Ä¸       a,b    |b evenly distributed over the elements of a
Â¶              |"\n"
â‹       a      |vertical_join(a)
â‘       a,b    |vertical_join(a, padding=b)
Åƒ       f,a    |first n integers where function f is true
Å„       f      |first integer where function f is true
â€¼       a      |factorial(a)
â¨Š       a      |cumulative_sums(a)
â‰ˆ       a      |all_equal(a) # every item is the same
Ã°              |" "
Ê—       a      |counts_of_items(a)
â—       a      |reversed(a)
âŠ       a      |a[:-1]
âˆ«              |sum(entire_stack)
â‹       a      |graded_up(a)
â’       a      |graded_down(a) # short for ÅŒÅ‰
â„•              |None # as in python's None type
âˆˆ       a,f    |a.indexes_where_truthy(fn)
â‚›       a,f    |sorted(a, key=fn) # sort by function result
Â£              |set register without emptying
Å’       a      |a * -1 # negate
Å“       a,b    |a % b == 0
â‰•       a,b    |a == b (vectorising)
â‰        a,b    |a != b (non-vectorising)
Â¥              |push register without emptying
â±       a,b    |a[b:] #other forms of indexing use i
â€¹       a,b    |a << b
â€º       a,b    |a >> b
â²       a,b    |a and b (bitwise) # a & b
â±       a,b    |a or b (bitwise) # a | b
â€¸       a,b    |a xor b (bitwise)
Â¡       a      |not a (bitwise) # ~a
âŠ‘       a,b    |a.insert(0, b)
â‰€       a,b,c  |a.insert(b, c)
â„…       a      |random element from a
â‰¤       a,b    |a <= b
â‰¥       a,b    |a >= b
â†œ              |stack[-2]
â‰—       a,b,c  |a[b] = c
â‹¯       a      |integer_partitions(a)
â§¢       a      |permutations(a)
Å©       a      |* treat compressed string as integer list
â°       a,b    |a[0:b]
Â¹       a,b    |a[1:b]
Âª              |* push index of next character in Vyxal's codepage
â‚‘       a      |exec(VyCompile(a))
ÏŠ       a      |range(1, len(a) + 1)
â‰       a      |group_consecutive(a)
â‡¿       a,b,c  |transliterate(a, b, c) # a: original b: new c: string
âŠ›       a      |truthy_indexes(a)
Ã—       a,b    |cartesian_product(a, b)
Â¯       a      |deltas(a)
Â±       a      |sign_of(a)
âŠ‚       a,b    |all combinations with length b of a
â              |all inputs wrapped in a list
á£              |print t.o.s without popping
â‚´       a      |time.sleep(a)
â‰       a      |transpose(a)
Îª       a      |range(0, len(a))
â‚              |most recent input
âŠ˜       a,b    |a.split_and_keep_delimiter(b)
á¶¢       a,(b)  |gcd(a) if a is a list, else gcd(a, b)
â‚Œ              |* apply the next two built-ins parallel 3 4 Å½+- -> 7 -1
â†­       a,b,c  |c,a,b
Å¿       f,a    |call function f, a times
Æ€       f,a,(b)|push Generator of function f with intial vector a, limited to b items (if present)
Æ       a      |bool(a)
âš       a       |a[:-1], a[-1]
âŒˆ       a      |ceiling(a)
âŒŠ       a      |floor(a)
âŠ“       a,b    |a wrapped in chunks of b
âŠ£       a,b    |a.trim(b) # Like Jelly's trim
á¸       a,b    |a.find(b)
á¸Ÿ       a,b,c  |a.find(b, start=c)
âˆª       a,b    |set union
âˆ©       a,b    |set intersection
âŠ       a,b    |set(a) ^ set(b)
âœ       a      |1 / a
âŒ‘       a      |is_perfect_square(a)
á¸†       a      |bifuricate(a)
â‚‚              |*second most recent input
â¾       a      |10 ** a
â‚¦       a      |a.split("\n")
Â¼       a      |a / 4
Æ’       a      |fractionify(a) # returns a two-item list of [numerator, denominator]
É–       a      |decimalify(a) # opposite of Æ’
ğ’«       a      |powerset(a)
â€²       a      |prime_factorisation(a)
\n             |NOP
\t             |NOP
<space>        |NOP
â‚¥      a       |average(a)
â€³      a       |ath prime
Î±              |push 26
Î²              |push 64
Î³              |push 128
Î       a       |product(a)
