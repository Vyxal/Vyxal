package vyxal

import scala.language.strictEquality

import vyxal.parsing.Range

import scala.collection.mutable.ListBuffer

// todo maybe record whether each AST has a breakpoint
enum AST(val arity: Option[Int]) derives CanEqual:
  case Number(value: VNum, override val range: Range = Range.fake)
      extends AST(Some(0))
  case Str(value: String, override val range: Range = Range.fake)
      extends AST(Some(0))
  case Lst(elems: List[AST], override val range: Range = Range.fake)
      extends AST(Some(0))
  case Command(
      value: String,
      arityOverride: Option[Int] = None,
      overwriteable: Boolean = true,
      override val range: Range = Range.fake,
  ) extends AST(
        arityOverride.orElse(Elements.elements.get(value).flatMap(_.arity))
      )

  /** Multiple ASTs grouped into one list */
  case Group(
      elems: List[AST],
      override val arity: Option[Int],
      override val range: Range = Range.fake,
  ) extends AST(arity)
  case SpecialModifier(modi: String, override val range: Range = Range.fake)
      extends AST(None)

  case RedefineModifier(
      name: String,
      mode: String,
      args: List[String],
      implArity: Int,
      var impl: Option[AST],
      override val range: Range = Range.fake,
  ) extends AST(None)
  case CompositeNilad(elems: List[AST], override val range: Range = Range.fake)
      extends AST(Some(0))

  case CompressedString(value: String, override val range: Range = Range.fake)
      extends AST(Some(0))
  case CompressedNumber(value: String, override val range: Range = Range.fake)
      extends AST(Some(0))
  case DictionaryString(value: String, override val range: Range = Range.fake)
      extends AST(Some(0))
  case Ternary(
      thenBody: AST,
      elseBody: Option[AST],
      override val range: Range = Range.fake,
  ) extends AST(Some(1))
  case IfStatement(
      conds: List[AST],
      bodies: List[AST],
      elseBody: Option[AST],
      override val range: Range = Range.fake,
  ) extends AST(Some(1))
  case For(
      loopVar: Option[String],
      body: AST,
      override val range: Range = Range.fake,
  ) extends AST(None)
  case While(
      cond: Option[AST],
      body: AST,
      override val range: Range = Range.fake,
  ) extends AST(None)
  case Lambda(
      lambdaArity: Option[Int],
      params: List[String | Int],
      body: List[AST],
      originallyFunction: Boolean = true,
      override val range: Range = Range.fake,
  ) extends AST(Some(lambdaArity.getOrElse(-2)))

  case DecisionStructure(
      predicate: AST,
      container: Option[AST],
      override val range: Range = Range.fake,
  ) extends AST(Some(1))
  case GeneratorStructure(
      relation: AST,
      inital: Option[AST],
      lookbackArity: Int,
      override val range: Range = Range.fake,
  ) extends AST(Some(1))

  /** A function definition, basically sugar a lambda assigned to a variable */
  case FnDef(name: String, lam: Lambda, override val range: Range = Range.fake)
      extends AST(Some(0))
  case ContextIndex(index: Int, override val range: Range = Range.fake)
      extends AST(Some(0))
  case GetVar(name: String, override val range: Range = Range.fake)
      extends AST(None)
  case SetVar(name: String, override val range: Range = Range.fake)
      extends AST(Some(1))
  case SetConstant(name: String, override val range: Range = Range.fake)
      extends AST(Some(1))
  case AuxAugmentVar(name: String, override val range: Range = Range.fake)
      extends AST(None)
  case AugmentVar(
      name: String,
      what: AST,
      override val range: Range = Range.fake,
  ) extends AST(None)
  case UnpackVar(
      names: List[(String, Int)],
      override val range: Range = Range.fake,
  ) extends AST(None)

  /** For code generated by a modifier */
  case Generated(
      exec: () => Context ?=> Unit,
      override val arity: Option[Int] = None,
  ) extends AST(arity)

  case Parameter(name: String) extends AST(None)

  def range: Range = Range.fake

  /** Generate the Vyxal code this AST represents */
  def toVyxal: String =
    this match
      case Number(n, _) => n.toString
      case Str(value, _) => s"\"$value\""
      case Lst(elems, _) => elems.map(_.toVyxal).mkString("#[", "|", "#]")
      case Command(value, _, _, _) => value
      case Group(elems, _, _) =>
        val asts = elems.toBuffer
        val newElems = ListBuffer[AST]()

        while asts.nonEmpty do
          val numbers = asts.takeWhile(_.isInstanceOf[Number])
          if numbers.nonEmpty then
            newElems += Command(numbers.map(_.toVyxal).mkString(" "), None)
            asts.remove(0, numbers.length)
          else
            newElems += asts.head
            asts.remove(0)

        newElems.map(_.toVyxal).mkString

      // case SpecialModifier(modi, value) => s"$modi"
      // ^ Might not need this because it'll be converted into different ASTs
      case CompositeNilad(elems, _) => elems.map(_.toVyxal).mkString
      case CompressedString(value, _) => s"\"$value“"
      case CompressedNumber(value, _) => s"\"$value„"
      case DictionaryString(value, _) => s"\"$value”"
      case Ternary(thenBody, elseBody, _) => s"[$thenBody|$elseBody}"
      case For(loopVar, body, _) =>
        s"(${loopVar.getOrElse("")}|${body.toVyxal}}"
      case While(cond, body, _) =>
        s"{${cond.fold("")(_.toVyxal)}|${body.toVyxal}}"
      case Lambda(lambdaArity, params, body, originallyFunction, _) =>
        s"λ${if params.nonEmpty then params.mkString("", ",", "|")
          else
            lambdaArity match
              case Some(arity) =>
                s"${if arity == -1 then "!" else arity.toString}|"
              case None => ""
          }${body.map(_.toVyxal).mkString("|")}}"
      case FnDef(name, lam, _) => ???
      case GetVar(name, _) => s"#$$$name"
      case SetVar(name, _) => s"#=$name"
      case Parameter(name) => s"$name,"
      case ast => ast.toString
end AST

object AST:
  /** Turn zero or more ASTs into one, wrapping in a [[AST.Group]] if necessary
    */
  def makeSingle(elems: AST*): AST =
    if elems.isEmpty then AST.Group(Nil, None)
    else if elems.size == 1 then elems.head
    else
      AST.Group(
        elems.toList,
        None,
        range = Range(elems.head.range.startOffset, elems.last.range.endOffset),
      )

  /** Create an [[AST.Command]] that calls a builtin element */
  def builtin(element: String, range: Range = Range.fake): AST.Command =
    Elements.elements.get(element) match
      case Some(elem) => AST.Command(element, elem.arity, false, range)
      case None =>
        throw VyxalYikesException(s"Element $element doesn't exist but should")
end AST

enum CustomElementType derives CanEqual:
  case Element
  case Modifier

enum Visibility(val sigil: String) derives CanEqual:
  case Public extends Visibility("!")
  case Private extends Visibility("=")
  case Restricted extends Visibility("$")

case class CustomDefinition(
    name: String,
    elementType: CustomElementType,
    impl: Option[AST],
    arity: Option[Int],
    args: (List[String | Int], List[String | Int]),
)

case class CustomClass(
    fields: Map[String, (Visibility, Option[AST])]
)
