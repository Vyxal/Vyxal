ᵃ = Reduce each overlap of size 2 by an element / number of truthy items by element
ᵇ = Apply element without popping / remove duplicates by element
ᶜ = reduce columns / map over suffixes
ᵈ = Next element as a dyadic function
ᵉ = Next two elements as a dyadic function
ᶠ = Next three elements as a dyadic function
ᶢ = Next four elements as a dyadic function
ᴴ = Apply element only to the head of list
ᶤ = find the index for the first element such that function evaluates as truthy
ᶨ = Loop an element. Repeat until the results are no longer unique. Record intermediate results.
¶ = NOP
ᵏ = Key. Map an element over the groups formed by identical items.
ᶪ = Loop an element. Repeat until the results are no longer unique.
ᵐ = maximum by element
ⁿ = mimimum by element
ᵒ = Outer Product / Table
ᵖ = map over prefixes
ᴿ = Apply next element to register
ᶳ = Sort by element
ᵗ = Tie. Cycle through a number of (default 2) elements each time called.
ᵘ = run func on the prev result until the result no longer changes returning all intermediate results
ᵛ = vectorise over rows (map with each row as entire input)
ᵂ = Pop the top value of the stack, apply a function to the rest, and push the popped value back.
ᵡ = scan fixedpoint [apply until a previous value is repeated, collecting intermediate results]
ᵞ = vertical scan / invariant under?
ᶻ = zipwith / all neighbours [apply to neighbours (windows of length 2) and check if all elements are equal]
ᶴ = Two character string
⸠ = Next Element as Function
ϩ = Next Two Elements as Function
э = Next Three Elements as Function
Ч = Next Four Elements as Function
ᵜ = Lambda to start of line
  = NOP
! = Factorial / Uppercase
" = String
# = Digraph
$ = Swap
% = Modulo / String format / <str, num>
& = Concatenate ([1, 2, 3] & [4, 5] = [1, 2, 3, [4, 5]])
' = single character
( = for-loop start
) = close two structures
* = exponentation / remove nth letter / trim - Trim all elements of y from both sides of x.
+ = addition / string concat
, = print
- = subtraction / remove string
. = decimal
/ = Foldl / Reduce left / Filter by Element
0 = numeric literal
1 = numeric literal
2 = numeric literal
3 = numeric literal
4 = numeric literal
5 = numeric literal
6 = numeric literal
7 = numeric literal
8 = numeric literal
9 = numeric literal
: = duplicate
; = [a, b]
< = less than
= = equals
> = greater than
? = input
@ = Apply at indices (modifier)
A = All
B = To binary
C = Count of rhs in lhs
D = Triplicate
E = 2 ** n / Evaluate
F = Filter by function / lhs in base 10 from rhs
G = Monadic maximum <any, lst> / Dyadic maximum <non-lst, non-lst|non-fun> / Generate from function <lst, fun> / Vectorised maximum <lst, non-lst|non-fun>
H = To/from hexadecimal
I = Interleave
J = Merge ([1, 2, 3] J [4, 5] = [1, 2, 3, 4, 5])
K = Factors / is numeric
L = Length
M = Map function to list / Mold one list to the shape of another / Multiplicity (how many times does rhs divide lhs) / <str, str> / <str, num>
N = Negate / swap case / first non-negative integer where a pred is true
O = Ord / chr
P = Prefixes
Q = Exit
R = Reduce by function / range between two numbers / regex match?
S = Sort input ascending
T = Triple / Contains only alphabet? / Transpose list
U = Uninterleave
V = Vectorised reverse / complement (1 - z) / title case
W = Wrap stack
X = Return early
Y = List repeat lhs rhs times
Z = Zip lhs and rhs / zip map
[ = Open if statement
\ = scanl / Reject by Element
] = Close to <something>
^ = Reverse stack
_ = pop and discard
` = apply last element to each item, treating the item as a stack: ƛ~}
a = any()
b = from binary
c = lhs contains rhs
d = double / dyadify
e = even? / split string on newlines
f = flatten
g = monadic minimum / Dyadic minimum <non-lst, non-lst|non-fun> / Generate from function <lst, fun> but differently to G / Vectorised minimum <lst, non-lst|non-fun>
h = head lhs[0]
i = index / Apply b on a and collect unique values. Does include the initial value.
j = join on / vectorised repeat
k = constant digraph
l = vectorising lengths
m = context 1
n = context 2
o = overlaps
p = prepend
q = quotify
r = replace
s = split
t = tail lhs[-1]
u = unique / dedup
v = Vectorise element
w = wrap item
x = recurse
y = lhs to base rhs
z = [0, n] / is lowercase?
{ = open while loop
| = structure thing
} = close structure
~ = 2 byte compressed number
¦ = "|"
Ȧ = Absolute value / keep only alphabet characters
Ḃ = Return a Boolean array with 1s at the indices in a list.
Ċ = Cycle a list infinitely / is positive?
Ḋ = Divides? / Remove duplicates by function result / lhs + " " * rhs
Ė = Eval as vyxal / 10 ** n
Ḟ = Find
Ġ = Group by function result
Ḣ = a[1:]
İ = Index into (alt: slice) / a + bj / Apply b on a and collect unique values. Does not include the initial value.
Ŀ = Logarithm / scan fixedpoint [apply until a previous value is repeated, collecting intermediate results] / len(lhs) == rhs
Ṁ = Modular; return every y th element of x. If y is zero, mirror: prepend x to its reverse. <lst/str, num>
    / Matrix multiply <lst, lst> / regex fullmatch? <str, str>
Ṅ = Join on nothing / integer partitions / first truthy integer where function
Ȯ = Over
Ṗ = Permutations
Ṙ = Rotate left
Ṡ = Vectorised sums / num to str / is numeric?
Ṫ = a[:-1]
Ẇ = Wrap a list in chunks of a certain length / <str, str> / first n truthy integers where function
Ẋ = Carteisan product
ι = range [0, length(lhs))
κ = range [1, length(lhs)]
ȧ = absolute difference / apply to neighbours [applies to windows of length 2] /
ḃ = a % 2 / second half of string
ċ = n choose k / <num, str> / set of chars in lhs == set of chars in rhs
ḋ = dot product / convert a to bijective base b
ė = reciprocal / remove whitespace
ḟ = prime factors / remove non-alphabet characters
ġ = group by consecutive items
ḣ = a[0], a[1:]
ŀ = transliterate / call b on c until a(c) is falsy
ṁ = mirror
ṅ = "\n".join(lhs) / pad with 0s to nearest positive multiple of 8 / if 1, push context variable n
ȯ = Insert zeros (or blanks) in B corresponding to zeros in A
ṗ = list partitions
ṙ = rotate right
ṡ = reshape array to certain shape / sort list by function
ṫ = a[:-1], a[-1]
ẋ = cartesian power /
ƒ = flatten by depth
Θ = a[0:b]
Φ = a[1:b]
§ = print without newline
Ạ = a[b] = c
Ḍ = Decision problem structure
Ẹ = partition at truthy indices
Ḥ = a[1:], a[0]
Ị = insert b at index c into a
Ḷ = sort by lengths
Ṃ = matrix inverse / bit length of a number (vectorises on 1d lists)
Ṇ = Generator structure
Ọ = Print without popping
Ṛ = Reverse
Ṣ = sublists
Ṭ = trim / Trim all elements of y from both sides of x.
… = x + 2 / [x[0] for x in y]
≤ = less than or equal to
≥ = greater than or equal to
≠ = not equals
₌ = strictly equals
⁺ = shortcut for 2Ẇ
⁻ = cube a number / shortcut for 3Ẇ on strings
⁾ = append and prepend b to a / repeat each character in a b times.
√ = square root
∑ = sum
« = bitshift left
» = bitshift right
⌐ = bit not
∴ = bit and
∵ = bit or
⊻ = bit xor
₀ = 10
₁ = 16
₂ = 26
₃ = 32
₄ = 64
₅ = 100
₆ = 128
₇ = 256
₈ = alphabet
₉ = []
λ = Normal lambda
ƛ = Mapping lambda
Ω = Filter lambda
₳ = Reduce lambda
µ = Sorting lambda
∆ = Digraphs
ø = Digraphs
Þ = Digraphs
½ = Halve
ʀ = [0, n)
ɾ = [1, n]
¯ = Deltas
× = Multiplication / string repetition / ring translate
÷ = Division / split string on another string
£ = Set register
¥ = get register
← = rotate stack left
↑ = grade up
→ = rotate stack right
↓ = grade down
± = sign of
¤ = context args
† = Shortcut for ĠvL (group consecutive, vectorised lengths)
¬ = not
∧ = logical and
∨ = logical or
⁰ = first input
¹ = second input
² = third input
³ = fourth input
Ɠ = min without popping
ɠ = max without popping
∥ = Parallel apply (coerces arities into -1/apply to stack)
∦ = Parallel apply into list (coerces arities into -1/apply to stack)
ı = complex number literal
„ = close compressed number
” = close dictionary string
ð = space
€ = suffixes
“ = close compressed string
¶ = newline
ᶿ = unsafe cartesian product (doesn't work on inf lists)
ᶲ =
• = asterisk
≈ = all equal?
¿ = Conditional Execution
ꜝ = Inner-product by element
#X = Break from loop
#x = Continue loop
