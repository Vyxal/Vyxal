λ                                         = lambda - λ...;
ƛ                                         = lambda that automatically gets mapped - ƛ...;
¬  (any a) -> num                         = logical NOT (non-vectorising)
∧  (any a, any b) -> num                  = logical AND
⟑  (any a, any b) -> [*num]               = vectorised AND
∨  (any a, any b) -> num                  = logical OR
⟇  (any a, any b) -> [*num]               = vectorised OR 
÷  (num a, num b) -> num                  = a / b # division
   (num a, str b) -> [*str]               = b split into a even length pieces. There may be an extra part if the string is too long.
   (str a, num b) -> [*str]               = a split into b even length pieces. There may be an extra part if the string is too long.
   (str a, str b) -> [*str]               = a.split_on_first_occurance(b)
   (otherwise)                            = vectorise
×  (num a, num b) -> num                  = a × b # multiply, multiplication, times
   (num a, str b) -> str                  = b repeated a times
   (str a, num b) -> str                  = a repeated b times
   (str a, str b) -> [*str]               = [char + b for char in a]
   (otherwise)                            = vectorise
«                                         = base-255 compressed string - «...«
<newline>                                 = NOP # no-op, nothing
»                                         = base-255 compressed number - »...»
°                                         = function reference - °defined_function_name;
•  (num a, num b) -> num                  = log_a(b)
   (num a, str b) -> [*str]               = [char * a for char in b]
   (str a, num b) -> [*str]               = [char * b for char in a]
   (str a, str b) -> str                  = a.with_capitalisation_of(b)
   ([*any] a, [*any] b) -> [*any]         = a molded to the shape of b
   (otherwise) -> [*any]                  = vectorise
¿  (any a, any b?) -> any                 = apply element if a is truthy - <element>¿
⋄  (num a) -> num                         = number of prime factors
   (str a) -> any                         = execute as Vyxal
   (fun a, any... b) -> any               = call function
   ([*any]) -> [*any]                     = vectorise
μ                                         = last element as a function - <element>μ
ξ                                         = last two elements as a single element - <element><element>ξ
π                                         = last three elements as a single element - <element><element><element>π
ρ                                         = last four elements as a single element - ....ρ
ς  (any a) -> [*any]                      = inner product - <element>ς
σ  (any a) -> [*any]                      = sort by element - <element>σ
φ  (any a) -> [*any]                      = everything until last φ as an element. if no previous φ, until newline
χ                                         = everything to the start of the line as a single element
ψ  (any a, any b?, any c?) -> any, any    = apply last two elements "parallel" - 3 4 +-ψ -> 7, -1
ω  (any a, any b?, any c?) -> [*any]      = apply last two elements "parallel" and collect - equivalent to ψ"
ɓ                                         = perform last element without popping - <element>ɓ
ƈ  (any a) -> [*any]                      = collect while applying last element is truthy - <element>ƈ
ɗ  ([*any] a) -> any                      = maximum by last element - <element>ɗ
ƒ  ([*any] a) -> [*any]                   = filter by last element - <element>ƒ
ɠ  ([*any] a) -> [*any]                   = minimum by last element - <element>ɠ
ɦ  ([*any] a) -> [*any]                   = map last element over prefixes - <element>ɦ
<space>                                   = NOP
!  (num a)                                = factorial(a)
   (str a)                                = sentence_case(a)
   ([*any] a)                             = vectorise
"  (any a, any b) -> [*any]               = [a, b] (pair items)
#                                         = comment
$  (any a, any b) -> any, any             = b, a (swap items)
%  (num a, num b) -> num                  = a % b # modulo
   (num a, str b) -> str                  = (b split into a equal pieces)[-1]
   (str a, num b) -> str                  = (a split into b equal pieces)[-1]
   (str a, str b) -> str                  = a.format(b)
   (str a, [*any] b) -> str               = a.format(b)
   (otherwise) -> [*any]                  = vectorise
&                                         = apply last element to the register - <element>&
'                                         = single character string
(                                         = open for loop: (variable|...)
)                                         = close for loop
*  (num a, num b) -> num                  = a ** b # exponent, exponentiation
   (num a, str b) -> str                  = every ath letter of b
   (str a, num b) -> str                  = every bth letter of a
   (str a, str b) -> [*num]               = regex.search(pattern=a, string=b).span()
   (otherwise) -> [*any]                  = vectorise
+  (num a, num b) -> num                  = a + b # addition
   (num a, str b) -> str                  = concat(a, b)
   (str a, num b) -> str                  = concat(a, b)
   (str a, str b) -> str                  = concat(a, b)
   (otherwise) -> [*any]                  = vectorised
,  (any a)                                = print(a)
-  (num a, num b) -> num                  = a - b # subtraction
   (num a, str b) -> str                  = ("-" × a) + b
   (str a, num b) -> str                  = a + ("-" × b)
   (str a, str b) -> str                  = a.remove(b)
   (otherwise) -> [*any]                  = vectorise
.                                         = decimal seperator
/  (any a)                                = reduce by last element - <element>/
0                                         = numeric literal
1                                         = numeric literal
2                                         = numeric literal
3                                         = numeric literal
4                                         = numeric literal
5                                         = numeric literal
6                                         = numeric literal
7                                         = numeric literal
8                                         = numeric literal
9                                         = numeric literal
:  (any a) -> any, any                    = a, a  # duplicate
;                                         = closes a structure
<  (num a, num b) -> num                  = a < b (less than)
   (num a, str b) -> num                  = str(a) < b
   (str a, num b) -> num                  = a < str(b)
   (str a, str b) -> num                  = a < b (python string less than)
   ([*any] a, scl b) -> [*num]            = [n < b for n in a]
   ([*any] a, [*any] b) -> [*num]         = [a[n] < b[n] for n in range(len(a))]
=  (scl a, scl b) -> num                  = a == b
   ([*any] a, scl b) -> [*num]            = a == b # vectorising equals
   ([*any] a, [*any] b) -> [*num]         = a == b # vectorise element wise
<  (num a, num b) -> num                  = a < b (less than)
   (num a, str b) -> num                  = str(a) < b
   (str a, num b) -> num                  = a < str(b)
   (str a, str b) -> num                  = a < b (python string less than)
   ([*any] a, scl b) -> [*num]            = [n < b for n in a]
   ([*any] a, [*any] b) -> [*num]         = [a[n] < b[n] for n in range(len(a))]
?  -> any                                 = input()
@                                         = define a function: @name:parameters|...;
                                          = call a function: @name;
A  ([*any] a) -> num                      = all(a)
B  (scl a) -> num                         = int(a, 2)
   ([*any] a) -> [*num]                   = vectorise
C  (num a) -> str                         = chr(a)
   (str a) -> num OR [*num]               = ord(a) if len(a) == 1 else map(ord, a)
   (otherwise) -> [*any]                  = vectorise
D  (any a) -> any, any, any               = a, a, a (triplicate)
E  (num a) -> num                         = 2 ** a # 2 power, two power
   (str a) -> any                         = eval(a)
   (otherwise) -> [*any]                  = vectorise
F  (val a, val b) -> any                  = remove elements of a that are in b
   ([*any] a, fun b) -> [*any]            = filter(b, a) # filter, keep, python filter
   (fun a, [*any] b) -> [*any]            = filter(a, b) # filter, keep, python filter
G  ([*any] a) -> any                      = max(a) # monadic maximum, maximum iterable
H  ([*any] a) -> any                      = a[0]
I  (num a) -> num                         = int(a)
   (str a) -> num                         = int(a)
   ([*any] a) -> num                      = int(a) using list items as digits
J  ([*any] a, scl b) -> [*any]            = a.append(b) # Append
   (scl a, [*any] b) -> [*any]            = b.prepend(a) # Prepend
   ([*any] a, [*any] b) -> [*any]         = merged(a, b) # Merge
   (scl a, scl b) -> scl                  = concatenated(a, b) # Concatenate
K  (num a) -> [*num]                      = divisors(a)
   (str a) -> [*str]                      = prefixes(a)
   (otherwise) -> [*any]                  = prefixes(a)
L  (any a) -> num                         = len(a)
M  (val a, val b) -> [[any, any]]         = [[a, item] for item in b] # Vectorised pair
   ([*any] a, fun b) -> [*any]            = map(b, a)
   (fun a, [*any] b) -> [*any]            = map(a, b)
N  (num a) -> num                         = -a (negate)
   (str a) -> str                         = swapcase(a)
   ([*any] a) -> [*any]                   = vectorise
O  (any a, any b) -> num                  = a.count(b) (non-vectorising)
P  (any a, any b) -> [*any]               = prepend b to a
Q                                         = stop execution (quit)
R  (val a, val b) -> any, [*any]          = a, vectorised_reverse(b)
   ([*any] a, fun b) -> [*any]            = reduce a by b # reduction, reduce
   (fun a, [*any] b) -> [*any]            = reduce b by a # reduction, reduce
S  (num a) -> str                         = str(a)
   (str a) -> [*str]                      = a.splitlines()
   ([*any] a) -> [*any]                   = vectorise
T  (any a) -> any                         = a[-1]
U  (any a) -> [*any]                      = uniquifed(a) # uniquify, unique items
V  (any a, any b, any c) -> [*any]        = a.replace(b, c)
W  (any a) -> [any]                       = [a] # wrap item
X  (num a) -> num                         = random.choice(range(a))
   (str a) -> str                         = random.choice(a)
   ([*any] a) -> any                      = random.choice(a)
Y  (any a) -> [*any], [*any]              = uninterleave(a)
Z  (any a, any b) -> [[any, any]]         = zip(a, b)
   (any a, fun b) -> [*any]               = zip(a, map(b, a)) #zipmap, map and zip
[                                         = open if statement: [truthy|falsey]
\                                         = cumulative reduce by last element - <element>\
]                                         = close if statement
`                                         = string - `...`
^                                         = reverse stack
_  (any a)                                = discard/pop/trash
a  (any a) -> num                         = any(a)
b  (num a) -> [*num]                      = binary repr of a
   (str a) -> [[*num]]                    = [bin(ord(char)) for char in a]
   ([*any] a) -> [*any]                   = vectorise
c  (any a, any b) -> num                  = a in b (contains)
d  (num a) -> num                         = a × 2
   (str a) -> str                         = a + a
   ([*any] a) -> [*any]                   = vectorise
e  (num a, num b) -> num                  = copysign(a, b)
   (num a, str b) -> [*str]               = Split b into two sections, the first of which has length a.
   (str a, num b) -> [*str]               = Split a into two sections, the first of which has length b.
   (str a, str b) -> [*str]               = Split a on the first occurance of b
   (fun a, num b) -> [*num]               = first b integers where a() is truthy
   (num a, fun b) -> [*num]               = first a integers where b() is truthy
   (otherwise) -> [*any]                  = vectorise
f  (num a) -> [*num]                      = list of a's digits
   (str a) -> [*str]                      = list of a's characters
   (otherwise) -> [*any]                  = flattened(a) # flatten, deep flatten
g  ([*any] a) -> any                      = min(a) # monadic minimum, minimum iterable
h  (any a, num b) -> [*any]               = a[0:b] # Slice until b
   (str a, str b) -> [*any]               = regex.findall(pattern=a, string=b) # re.findall
   (otherwise) -> [*any]                  = vectorise
i  (any a, num b) -> any                  = a[b] # index
   (any a, [*num] b)                      = a[:b] # 0 to bth item of a, use t for a[b:], needs wrapping index
   (any a, [num x, num y] b)              = a[x:y] # index, xth to yth item, needs wrapping index
   (any a, [num x, num y, num m] b)       = a[x:y:m] # index, xth to yth item step m items, needs wrapping index
j  (any a, any b) -> str                  = a.join(b)
k                                         = constant digraphs (see near the end of docs)
l  (any a, num b) -> [[*any]]             = n-wise_group(a, b) # Cummulative grouping/pairing
   (any a, [*any] b) -> num               = length(a) == length(b) # Length of a and b are same?
m  (any a)                                = mirror(a) # numbers are reversed and added
n                                         = context variable
o  (num a, num b) -> num                  = how many times does b divide a?  # order
   (num a, str b) -> str                  = a * a grid of b, joined with newlines
   (str a, num b) -> str                  = b * b grid of a, joined with newlines
   (str a, str b) -> str                  = remove b from a until a does not change
   (otherwise) -> [*any]                  = vectorise
p  (num a, num b) -> [*num]               = range(a, b + 1)  # inclusive range from a to b
   (num a, str b) -> [*str]               = cartesian_power(b, times=a)
   (str a, num b) -> [*str]               = cartesian_power(a, times=b)
   (num a, [*any] b) -> [*any]            = cartesian_power(b, times=a)
   ([*any] a, num b) -> [*any]            = cartesian_power(a, times=b)
   (str a, str b) -> str                  = a.strip(b)
   (otherwise) -> [*any]                  = vectorise
q  (any a) -> str                         = "`" + a + "`" # uneval, quotify
r  (num a, num b) -> [*num]               = range(a, b) # Exclusive range from a to b
   (num a, str b) -> str                  = stretch left; repeat the first character of b enough times to make it at least length a. Use spaces if b is empty.
   (str a, num b) -> str                  = stretch left; repeat the first character of a enough times to make it at least length b. Use spaces if a is empty.
   (any a, fun b) -> [*any]               = cumulative_reduce(a, function=b) # also works with (fun a, any b), Cumulative reduce
   (otherwise) -> num                     = regex.has_match(pattern=a, string=b) # regex match
s  (any a) -> any                         = sorted(a) # min → max, sort
t  (any a, num b) -> [*any]               = a[b:] # slice from b
   (str a, str b) -> [*any]               = regex.match(pattern=a, string=b).groups() # regex groups
   (otherwise) -> [*any]                  = vectorise
u  ([*any] a, num b) -> [*any]            = rotate a b units to the left
   (any a, [*any] b) -> any, [*any]       = a, b rotated to the left once
v                                         = vectorise last element - <element>v
w  (any a, num b) -> [*any]               = a wrapped in chunks of length b
   (any a, str b) -> [*any]               = split a on b, discarding empty items
   ([*any] a, fun b) -> [*any]            = apply b to every second item of a
   (fun a, [*any] b) -> [*any]            = apply a to every second item of b
x                                         = call current function # recursion. Prints entire stack if not in a function/lambda
y  (any a, any b) -> any                  = interleave(a, b) # Interleave
z  (any a) -> [*any]                      = zip(a, a)
{                                         = open while loop: {condition|...}
|                                         = branch in structure (syntax), Used to seperate blocks in If/For/While/Lambda/Function definition
}                                         = close while loop
~  ([*any] a) -> any...                   = push each item of a onto the stack
½  (num a) -> num                         = a / 2 # half, halve
   (str a)  -> [*str]                     = a split into two strings of equal lengths (as close as possible)
   ([*any] a) -> [*any]                   = vectorised
Ȧ  ([*any] a, num b, any c) -> [*any]     = a[b] = c
Ḃ  (any a) -> any, any                    = a, reversed(a)
Ċ  (num a, num b) -> [num, num]           = a choose b
   (num a, str b) -> str                  = diagonal of char b of length a - 5`/`Ċ -> `    /\n   / \n  / \n /   \n/    `
   (str a, num b) -> str                  = diagonal of char a of length b
   (str a, str b) -> str                  = a.partition(b)
   ([*any] a, scl b) -> [*num]            = b in a (vectorised)
   (scl a, [*any] b) -> [*num]            = a in b (vectorised)
   ([*any] a, [*any] b) -> [*num]         = [n in a for n in b]
Ḋ  (num a, num b) -> num                  = a % b == 0
   (num a, str b) -> str                  = anti-diagonal of char b of length a - 5`/`Ḋ -> `/    \n /   \n  /  \n   / \n    /`
   (str a, num b) -> str                  = diagonal of char b of length a
   (str a, str b) -> str                  = overwrite the start of a with b -> `abcdef` `Joe`Ḋ -> `Joedef`
   (otherwise) -> [*any]                  = vectorise
Ė  (num a, num b) -> num                  = a // b (integer divide)
   (str a, str b) -> str                  = b + a + b (surround)
   (fun a, any b) -> any                  = apply a to every second item of b
   (any a, fun b) -> any                  = apply b to every second item of a
   (otherwise) -> [*any]                  = vectorise
Ḟ  (any a, any b) -> num                  = a.find(b)
Ġ  (num a) -> num                         = 1 / a
   (str a) -> [*str]                      = a split into int(sqrt(a)) parts
   ([*any] a) -> [*any]                   = vectorise
Ḣ  ([*any] a) -> [*any]                   = a[1:b]
İ  (num a) -> num                         = proper divisor count
   (str a) -> str                         = GET request with url=a
   ([*any] a) -> [*any]                   = matrix inverse of a
Ŀ  (any a, any b, any c) -> any           = transliterate(a, b, c) # Transliterate
   (fun a, fun b, any c) -> any           = repeat_until_false(predicate=a, modifying_function=b, inital=c) # equivalent to ŀt
Ṁ  (num a, num b) -> [*num]               = roots of quadratic ax^2 + bx = 0 # Solve quadratic equation
   (num a, str b) -> num                  = evaluate single variable equation b with x=a
   (str a, num b) -> num                  = evaluate single variable equation a with x=b
   (str a, str b) -> num                  = set(a) == set(b) # Check if two lists are same except duplicates
   ([*any] a, [*any] b) -> [*any]         = matrix multiply a and b
   (fun a, [*any] b) -> any               = right reduce b by a # foldr
   ([*any] a, fun b) -> any               = right reduce a by b # foldr
   (otherwise) -> [*any]                  = vectorised
Ṅ  (num a) -> [*num]                      = integer_paritions(a) # Integer partitions
   (str a) -> str                         = insert spaces between characters
   ([*any] a) -> str                      = join on spaces
   (fun a) -> num                         = first integer where a(x) is truthy
Ȯ  (num a) -> num                         = log_2(a)
   (str a) -> str                         = remove all non-alphanumeric characters from a
   ([*any] a) -> [*any]                   = sums of rows (∑v)
Ṗ  (any a) -> [*any]                      = permutations(a) # Permutations
Ṙ  (any a) -> any                         = reverse a
Ṡ  (num a) -> [*num]                      = range from −abs(a) to abs(a) inclusive
   (str a) -> any                         = exec(a) # Execute python code, Python exec
   ([*any] a) -> [*any]                   = sums of columns of a
Ṫ  (num a) -> num                         = len(prime_factors(a)) # Number of prime factors
   (str a) -> str                         = read from file a
   ([*any] a) -> [*any]                   = transpose a
Ẇ  (num a, num b) -> [*num]               = a * b array of 0s
   (num a, str b) -> str                  = stretch right; repeat the first character of b enough times to make it at least length a. Use spaces if b is empty.
   (str a, num b) -> str                  = stretch right; repeat the first character of a enough times to make it at least length b. Use spaces if a is empty.
   (str a, str b) -> num                  = insert b between each character of a
   ([*any] a, [*any] b) -> [*any]         = dot product of a and b
   ([*any] a, fun b) -> [*any]            = map b over prefixes of a
   (fun a, [*any] b) -> [*any]            = map a over prefixes of b
   (otherwise) -> [*any]                  = vectorise
Ẋ  ([*any] a, [*any] b) -> [*any]         = cartesian product
   ([*any] a, fun b) -> [*any]            = map b over suffixes of a
   (fun a, [*any] b) -> [*any]            = map a over suffixes of b
Ẏ  ([*any] a) -> [*any]                   = cartesian product with self (:Ẋ)
Ż  ([*any] a, any b) -> [*any]            = zip(a, filler=b)
ȧ  (num a) -> num                         = abs(a)
   (str a) -> str                         = remove whitespace from a
   ([*any] a) -> [*any]                   = vectorise
ḃ  (num a) -> num                         = a != 0
   (str a) -> num                         = len(a) != 0
   ([*any] a) -> [*num]                   = vectorise
ċ  (num a, num b) -> num                  = a choose b
   (num a, str b) -> [*str]               = l but sublists are joined as a string instead
   (str a, num b) -> [*str]               = l but sublists are joined as a string instead
   (str a, str b) -> str                  = replace spaces in a with b
   (fun a, num b) -> [*num]               = first b integers where a() is truthy, starting at 1
   (num a, fun b) -> [*num]               = first a integers where b() is truthy, starting at 1
   (otherwise) -> [*any]                  = vectorise
ḋ  (num a, num b) -> [*num]               = [a / b, a % b]  # divmod, div mod, [div, mod], Quotient and modulo
   ([*any] a, num b) -> [*any]            = combinations of a with length b
   (num a, [*any] b) -> [*any]            = combinations of b with length a
   (str a, str b) -> str                  = a.trim(b)
   (fun a, any b) -> any                  = apply a on b until b doesn't change
   (any a, fun b) -> any                  = apply b on a until a doesn't change
ė  (any a) -> [*any]                      = enumerate(a) # :ʀZ
ḟ  (fun a, [*any] b) -> [*any]            = push Generator of function a with initial vector b
   (fun a, [*any] b, num c) -> [*any]     = push Generator of function a with initial vector b, limited to c items (if present)
ġ  (num a) -> num                         = (e ** a) - 1 # uses math.expm1()
   (otherwise) -> [*any]                  = format a as grid
ḣ  (num a) -> str                         = a to base 16
   (str a) -> num                         = a from base 16
   (otherwise) -> [*any]                  = vectorise
ŀ  (num a, num b, num c) -> num           = a <= c <= b
   (num a, num b, str c) -> str           = a by b grid of c
   (num a, str b, num c) -> str           = a by c grid of b
   (num a, str b, str c) -> str           = b.ljust(a,filler=c)
   (str a, num b, num c) -> str           = b by c grid of a
   (str a, num b, str c) -> str           = a.ljust(c,filler=b)
   (str a, str b, num c) -> str           = a.ljust(b,filler=c)
   (str a, str b, str c) -> str           = a.infinite_replace(b, c)
   (fun a, fun b, any c) -> any           = collect_until_false(predicate=a, modifying_function=b, inital=c) # Collect the results of apply a on c while b(c) is truthy
   (otherwise) -> [*any]                  = vectorise
ṁ  (num a) -> [*num]                      = all prime factors of a (includes duplicates)
   (str a) -> str                         = remove all non-letters of a `^[A-Za-z]`
   ([*any] a) -> any                      = determinant of matrix a. For non-square a, computes det(aa^T)^½; if z is a row vector, this is its norm.
ṅ  (num a) -> [*num]                      = integer_paritions(a) # Integer partitions
   (str a) -> str                         = insert newlines between characters
   ([*any] a) -> str                      = join on newlines
   (fun a) -> [*num]                      = all integers where a() is truthy
ȯ  (any a, any b) -> [*any]               = a.split_before(b) # https://chat.stackexchange.com/transcript/message/58361993#58361993
ṗ  (any a) -> [*any]                      = powerset(a)
ṙ  (num a, num b) -> num                  = round a to b decimal places
   ([*any] a, any b) -> [*any]            = remove b from a
   ([*any] a, fun b) -> any               = cumulative right reduce a by b
   (fun a, [*any] b) -> any               = cumulative right reduce b by a
ṡ  (num a, num b) -> num                  = [a * b, a / b]
   ([*any a], val b) -> [*any]            = split a on b
   ([*any a], fun b) -> [*any]            = sort a by function b
   (fun a, [*any b]) -> [*any]            = sort b by function a
ṫ  (num a) -> num                         = prime factorisation of a
   ([*any a]) -> [*any], any              = a[:-1], a[-1] # tail extract
ẇ  (num a, num b, num c) ->               = range from a to b with step c
   (num a, num b, str c) ->               = shape c as an a * b rectangle
   (num a, str b, num c) ->               = shape b as an a * c rectangle
   (num a, str b, str c) ->               = pad b on both sides with a prefix of repeated copies of c to a length of the nearest multiple of a
   (str a, num b, num c) ->               = shape a as a b * c rectangle
   (str a, num b, str c) ->               = pad c on the left with a prefix of repeated copies of a to a length of the nearest multiple of b
   (str a, str b, num c) ->               = pad a on the right with a prefix of repeated copies of b to a length of the nearest multiple of c
   (str a, str b, str c) ->               = regex substitution. In a, replace b with c
   ([*any] a, fun b, num c) -> [*any]     = b() applied to every cth element of a
   ([*any] a, fun b, [*num] c) -> [*any]  = b() applied to items in a with indexes in c
   (otherwise) -> [*any]                  = vectorise
ẋ  (any a, num b) -> [*any]               = repeat(a, times=b) # Repeat a b times
   (any a, str b) -> [*any]               = can each item of a be found in b?
ẏ  (num a, num b) -> num                  = are a and b coprime?
   (num a, str b) -> str                  = b repeated a times joined on newlines
   (str a, num b) -> str                  = a repeated b times joined on newlines
   (str a, str b) -> str                  = vertically merge a and b
   (otherwise) -> [*any]                  = vectorise
ż  (num a, num b, num c) -> num           = a >= c >= b
   (num a, num b, str c) -> str           = line of c of length a in direction b (0: north, 1: north-east, 2: east, 3: south-east, etc)
   (num a, str b, num c) -> str           = line of b of length a in direction c
   (num a, str b, str c) -> num, str      = spaces in b replaced with corresponding chars in c
   (str a, num b, num c) -> str           = line of a of length b in direction c
   (str a, num b, str c) -> str           = first b spaces in a replaced with corresponding chars in c
   (str a, str b, num c) -> str           = last c spaces in a replaced with corresponding chars in b
   (str a, str b, str c) -> num           = vertically mirror a using the mapping b->c
   (scl a, [*any b], [*num c]) -> [*any]  = stencil any-d
   ([*any a], num b, num c) -> [*any]     = stencil 2d (stencil takes overlapping submatrices from a matrix)
≤  (any a, any b) -> [*num]               = a <= b (similar to <=ψ∨)
≥  (any a, any b) -> [*num]               = a >= b (similar to >=ψ∨)
≠  (any a, any b) -> num                  = a != b (non-vectorising)
⁼  (any a, any b) -> num                  = a == b (non-vectorising)
©  (any a)                                = put a into the register
®         -> any                          = push register
∞         -> [*num]                       = infinite list of integers, starting at 0
₀         -> num                          = 10
₁         -> num                          = 100
₂  (num a) -> num                         = a % 2 == 0
   (str a) -> str                         = quad palindromize with overlap
   ([*any] a) -> [*any]                   = vectorise
₃  (num a) -> num                         = a % 3 == 0
   (str a) -> str                         = quad palindromize without overlap
₄          -> num                         = 26
₅  (num a) -> num                         = a % 5 == 0
   (str a) -> str                         = len(a) == 1
   ([*any] a) -> [*any]                   = vectorise
₆         -> num                          = 64
₇         -> num                          = 128
₈         -> num                          = 256
₉         -> num                          = 16
⁰         -> any                          = first input or "abcdefghijklmnopqrstuvwxyz"
¹         -> any                          = second input or "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
²  (num a) -> num                         = a ** 2
   (str a) -> [*str]                      = a formatted as a square
   ([*any] a) -> [*any]                   = vectorise
³         -> any                          = third input or 512
⁴         -> any                          = fourth input or []
⁵         -> any                          = fifth input or " "
∑  ([*any] a) -> any                      = sum(a) # Sum
¦  ([*any] a) -> [*any]                   = cumulative_sum(a)  # cumulative sum
⌈  (num a) -> num                         = ceiling(a) # Ceiling, ceil
   (str a) -> [*str]                      = a.split(" ") # Split on space
⌊  (num a) -> num                         = floor(a)
   (str a) -> str                         = int(keep only digits of a)
¯  ([*any] a) -> [*any]                   = deltas(a) # differences, cumulative subtraction
±  (num a) -> num                         = sign_of(a) # negative = -1, 0 = 0, positive = 1, signum
   (str a) -> str                         = a formatted into rectangle with smallest perimeter
↳  (num a, num b) -> num                  = a >> b # Right bit shift, right shift
   (str a, num b) -> str                  = a.rjust(b) # right justify
   (num a, str b) -> str                  = b.rjust(a) # right justify
   (str a, str b) -> str                  = a.rjust(len(b) - len(a)) # right justify by length
   (otherwise) -> [*any]                  = vectorised
↲  (num a, num b) -> num                  = a << b # Left bit shift, left shift
   (str a, num b) -> str                  = a.ljust(b) # left justify
   (num a, str b) -> str                  = b.ljust(a) # left justify
   (str a, str b) -> str                  = a.ljust(len(b) - len(a)) # left justify by length
   (otherwise) -> [*any]                  = vectorised
⋏  (num a, num b) -> num                  = a and b (bitwise) # a & b
   (str a, num b) -> str                  = a.center(b) # center
   (num a, str b) -> str                  = b.center(a) # center
   (str a, str b) -> str                  = a.center(len(b) - len(a)) # center by length
   (otherwise) -> [*any]                  = vectorised
⋎  (num a, num b) -> num                  = a or b (bitwise) # a | b
   (str a, num b) -> num                  = remove bth character of a
   (num a, str b) -> str                  = remove ath character of b
   (str a, str b) -> str                  = a and b joined on longest common prefix and suffix # `abc``cabc`⋎ -> `abcabc`
   (otherwise) -> [*any]                  = vectorised
꘍  (num a, num b) -> num                  = a xor b (bitwise)
   (str a, num b) -> str                  = a + " " * b # append b spaces to a
   (num a, str b) -> str                  = " " * a + b # prepend a spaces to b
   (str a, str b) -> num                  = levenshtein_distance(a, b) # Levenshtein distance of two strings
   (otherwise) -> [*any]                  = vectorised
ꜝ  (num a) -> num                         = not a (bitwise) # ~a
   (str a) -> num                         = are any letters in a uppercase?
   ([*any] a) -> [*any]                   = vectorised
”                                         = ""
‡  (any a, any b, any c) -> any, any, any = c, a, b # shift
⇧  (num a) -> num                         = a + 2
   (str a) -> str                         = a.uppercase()
   ([*any] a) -> [*num]                   = a graded up
⇩  (num a) -> num                         = a - 2
   (str a) -> str                         = a.lowercase()
   ([*any] a) -> [*num]                   = a graded down
∆                                         = mathematical digraphs
ø                                         = string digraphs
Þ                                         = list digraphs
¨                                         = misc./transformer digraphs
‘                                         = two char string
“                                         = dictionary string
ð  ([*any] a, [*num] b) -> [*any]         = [a[n] for a in b]
□                      -> [*any]          = [stack]
↑  (num a) -> num                         = next prime
   (str a) -> str                         = a.titlecase() # To title case
   ([*scl]) -> [*scl]                     = vectorise
   ([[any, any]] a) -> any                = max(a, key=lambda x: x[-1]) # Maximum by tail/last element
↓  (num a) -> num                         = ath prime
   (str a) -> str                         = substrings(a) # All substrings
   ([*scl]) -> [*scl]                     = vectorise
   ([[any, any]] a) -> any                = min(a, key=lambda x: x[-1]) # Minimum by tail/last element
∴  (any a, any b) -> any                  = max(a, b) # Maximum between a and b
∵  (any a, any b) -> any                  = min(a, b) # Minimum between a and b
›  (num a) -> num                         = a + 1
   (str a) -> str                         = last half of a
   ([*any] a) -> [*any]                   = vectorise
‹  (num a) -> num                         = a - 1
   (str a) -> str                         = a + "-"
   ([*any] a) -> [*any]                   = vectorise
β  (any a, num b) -> num                  = a to base 10 from arbitrary base b # Base conversion
   (str a, str b) -> num                  = a to base 10 from custom base b # Base conversion
τ  (num a, num b) -> [*num]               = a from base 10 to arbitrary base b # Base conversion
   (num a, str b) -> str                  = a from base 10 to custom base b # Base conversion
   (num a, [*any] b) -> [*num]            = a from base 10 to custom base b # Base conversion
¶                     -> str              = "\n"
§  (any a)                                = print(a, end="") # Print without newline
ε  (num a, num b) -> num                  = abs(a - b)
   (non-num a, num b) -> [*any]           = rotate a b units to the right
   (any a, [*any] b) -> any, [*any]       = a, b rotated to the right once
ʀ  (num a) -> [*num]                      = range(0, a + 1)
   (otherwise) -> [*num]                  = range(0, len(a) + 1)
ʁ  (num a) -> [*num]                      = range(0, a)
   (otherwise) -> [*num]                  = range(0, len(a))
ɾ  (num a) -> [*num]                      = range(1, a + 1)
   (otherwise) -> [*num]                  = range(1, len(a) + 1)
ɽ  (num a) -> [*num]                      = range(1, a)
   (otherwise) -> [*num]                  = range(1, len(a))
Π  (any a) -> any                         = product(a) # reduce by multiplication, product
⁽  (any a)                                = push a to global array
↕          -> [*any]                      = push global array
⁾          -> any                         = pop from global array and push to stack
⁺          -> num                         = index of next character in codepage + 101: ⁺<character>
Ɓ  ([*any] a) -> any                      = cycle reduce between two elements over a: <elementA><elementB>Ɓ -> ((a[0] elementA a[1]) elementB a[2] elementA a[3] ...
Ƈ  ([*any] a) -> any                      = foldr by last element: <element>Ƈ
Ɗ  ([*any] a) -> [*any]                   = cycle map last two elements over a: <elementA><elementB>Ɗ -> [A(a[0]), B(a[1]), A(a[2]), B(a[3])...]
Ƒ  ([*any] a) -> [*any]                   = map last element over pairs: <element>Ƒ
Ɠ  (any a, any... b)                      = if a is truthy, element B, else element A: ABƓ -> if a: A(b) else B(b)
Ƙ  ([*any] a) -> [*any]                   = map last element over suffixes
Ɱ  (any a, any b)                         = over: ABⱮ -> B(A(a), A(b))
Ɲ  (any a)                                = S combinator: ABƝ -> A(a, B(a))
Ƥ  (any... a)                             = parallel apply last N elements: ABCD...ZnƤ
Ƭ  (num a)                                = first a numbers where last element is truthy: <element>Ƭ
Ʋ  ([*any] a) -> [*any]                   = apply last element to each item, treating the item as a stack: <element>Ʋ -> ƛ~<element>;
Ȥ  ([*any] a) -> [*any]                   = zipwith: <element>
δ                 -> any                  = stack[-2]
⟨                                         = open a list: ⟨...⟩
⟩                                         = close a list
→  (any a)                                = variable set (= a): →name
←         -> any                          = variable get: ←name
∪ (any a, any b) -> [*any]                = set union # Merge without duplicates
∩ (any a, any b) -> [*any]                = set intersection # Common elements
⊍ (any a, any b) -> [*any]                = set(a) ^ set(b)
kA                                   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" (uppercase alphabet)
ke                                   = 2.718281828459045 (math.e, Eulers number)
kf                                   = "Fizz"
kb                                   = "Buzz"
kF                                   = "FizzBuzz"
kH                                   = "Hello, World!"
kh                                   = "Hello World"
k1                                   = 1000
k2                                   = 10000
k3                                   = 100000
k4                                   = 1000000
ka                                   = "abcdefghijklmnopqrstuvwxyz" (lowercase alphabet)
kL                                   = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" (uppercase+lowercase alphabet)
kd                                   = "0123456789" (Digits 0-9)
k6                                   = "0123456789abcdef" (Hex digits)
k^                                   = "0123456789ABCDEF" (Hex digits uppercase)
ko                                   = "01234567" (Octal digits)
kp                                   = string.punctuation (Punctuations)
kP                                   = printable ascii
kw                                   = All ASCII whitespace
kr                                   = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" (0-9A-Za-z)
kB                                   = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" (A-Za-z)
kZ                                   = "ZYXWVUTSRQPONMLKJIHGFEDCBA" (uppercase alphabet reversed)
kz                                   = "zyxwvutsrqponmlkjihgfedcba" (lowercase alphabet reversed)
kl                                   = "ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba" (Z-Az-a)
ki                                   = 3.141592653589793 (Pi)
kn                                   = math.nan
kD                                   = * Current day in the format YYYY-MM-DD
kN                                   = * Current time as a list of ⟨hh|mm|ss⟩
kḋ                                   = * Current day in the format DD/MM/YYYY
kḊ                                   = * Current day in the format MM/DD/YYYY
kð                                   = * Current day in the format ⟨DD|MM|YYYY⟩
kβ                                   = "{}[]<>()"
kḂ                                   = "()[]{}" (Brackets)
kƁ                                   = "()[]"
kḃ                                   = "([{" (Open brackets)
k≥                                   = ")]}" (Close brackets)
k≤                                   = "([{<" (Fish bones :P)
kΠ                                   = ")]}>"
kv                                   = "aeiou" (Vowels lowercase)
kV                                   = "AEIOU" (Vowels uppercase)
k∨                                   = "aeiouAEIOU" (vowelsVOWELS)
k⟇                                   = * Yields the Vyxal codepage
k½                                   = [1, 2]
k¦                                   = 2 ** 32, 2^32, 4294967296
k+                                   = [1, -1]
k-                                   = [-1, 1]
k⁼                                   = [0, 1]
k/                                   = "/\\"
kW                                   = "https://"
kẋ                                   = "http://"
k↳                                   = "https://www."
k²                                   = "http://www.
k₀                                   = 2048
k₁                                   = 4096
k₂                                   = 8192
k₃                                   = 16384
k₄                                   = 32768
k₅                                   = 65536
k₆                                   = 2147483648
k₇                                   = 1024
k₈                                   = 512
k₉                                   = 360
k⁰                                   = "bcfghjklmnpqrstvwxyz"
k¹                                   = "bcfghjklmnpqrstvwxz"
k□                                   = printable ascii
k•                                   = ["qwertyuiop", "asdfghjkl", "zxcvbnm"] (Qwerty keyboard)
kṠ                                   = current second
kṀ                                   = current minute
kḢ                                   = current hour
kτ                                   = day number of the year, day of year
kṡ                                   = seconds since epoch
k□                                   = [[0,1],[1,0],[0,-1],[-1,0]]
k‡                                   = [[0,1],[1,0]]
kɽ                                   = [-1,0,1]
k[                                   = "[]"
k]                                   = "]["
k(                                   = "()"
k)                                   = ")("
k{                                   = "{}"
k}                                   = "}{"
kẇ                                   = day of the week - 0 indexed
kẆ                                   = day of the week - 1 indexed
k§                                   = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
kɖ                                   = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
