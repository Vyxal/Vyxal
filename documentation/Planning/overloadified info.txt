F, G, H = monadic functions
f, g, h = dyadic functions
ḟ, ġ, ḣ = any arity

Modifiers

⎂F = ...d c b a => d c F(b) F(a)
⎂f = ...d c b a => f(d, c) f(a, b)
∥ḟġ = ...d c b a => d c ḟ(a, b) ġ(a, b)
∦ḟġ = ...d c b a => d c [ḟ(a, b), ġ(a, b)]
∺FG = ...d c b a => d c G(b) F(a)
~F = a.filter(F)
~f = ...d c b a => d c b a f(a, b)
/F = F(a) == a
/f = a.reduce(f)
\f = a.scan(f)
⁜F = a.group_by(apply function F to each)
⊞f = a.pairs.map(pair => pair.reduce(f))
▦f = [f(x, b) for x in a]
¨F = [F(x) for x in a]
¨f = [f(x, y) for (x, y) in zip(a, b)]
⊧f = Call f without depth or type switching
¿ḟ = if a then b()
⎇ḟ = ...d c b a => ...d ḟ(c, b) a

Elements

Types = num (number) str (string) lst (list) fun (function) any (any value) qnt (quantum value)
* after a pair of types indicates type switching occurs
! after a pair of types inicates depth switching (deeper on left, shallower on right)
A lack of a lst overload indicates auto-vectorisation.

a = lhs
b = rhs

⎊ (any) = [a, b, c] => something that is a, b, and c, all at the same time
⎋ (qnt) = create a list of all possible values the item can be
⍟ (qnt, num) = get the nth possible value
÷ (num, num) = a divided by b
  (str, num)* = split string b into chunks of size a
  (str, str) = split a on regex b
× (num, num) = a times b
  (str, num)* = repeat string a, b times
  (str, str) = ring translate
∧ (any, any) = b && a (first falsey)
∨ (any, any) = b || a (first truthy)
¬ (any) = not a (truthy => 0, falsey => 1)
ʀ (num) = range [0, a]
  (str) = uppercase
ʁ (num) = range [0, a)
  (str) = lowercase
ɾ (num) = range [1, a]
  (str) = is character a an alphabetical (a-zA-Z) letter?
‹ (num) = a - 1
  (str) = Pad string with 0s to length nearest multiple of 8
› (num) = a + 1
  (str) = Replace spaces with 0s
! (num) = Factorial
  (str) = Titlecase
$ (any, any) = ...d c b a => d c a b
% (num, num) = a modulo b
  (str, any) = a.format(b) # format on %s
& (any, any) = append b to a
* (num, num) = a to the power of b
+ (num, num) = a + b
  (str, num)* = str(a) + str(b)
  (str, str) = a + b
, (any) = Println
- (num, num) = a - b
  (str, num) = append b "-"s to a
  (num, str) = prepnd a "-"s to b
  (str, str) = remove all instance of regex b in a
: (any) = ...d c b a => d c b a a
; (any, any) = [a, b]
< (num, num) = a < b
  (str, num)* = str(a) < str(b)
  (str, str) = a < b (lexiographically)
= (num, num) = a == b
  (str, num)* = str(a) == str(b)
  (str, str) = a == b
> (num, num) = a > b
  (str, num)* = str(a) > str(b)
  (str, str) = a > b (lexiographically)
? = push input eval'd
@ (num, num) = |a - b|
  (str, str) = Levenshtein distance between a and b
  (any, fun)* = Reduce overlaps in list a by function b
A (num) = Are all digits of a truthy?
  (str) = Is character a vowel?
  (lst) = Are all items in a truthy?
B (num) = Convert a to binary (list of digits)
  (str) = each character in a to the binary representation of its character code
C (any, any)! = count of a in b
D (any) = ...d c b a => d c b a a a
E (num) = a ** 2
  (str) = Evaluate str (think python eval)
F (any, fun) = a.filter(b)
  (any, non-fun)! = a.find(b)
G (lst) = max(a)
  (scl, scl) = max(a, b)
H (num) = to_hex(a) (base 10 -> base 16)
  (str) = from_hex(a) (base 16 -> base 10)
I (any, fun)* = a.filter(x => !b(x)) (reject by)
  (any, non-fun) = Interleave
J (lst, lst) = a.addAll(b) (merge)
  (num, num) = int(s"$a$b")
K (num) = factors of a
  (str) = is string numeric
L (any) = length
M (any, fun)* = a.map(b)
  (lst, lst) = mold a to shape of b
  (num, num) = multiplicity
  (lst, num)* = vectorised num,num
N (num) = -a
  (str) = swap case
  (fun) = First non-negative integer x where a(x) is true
O (num) = character with corresponding character code
  (str) = number(s) that correspond to character codes
P (any) = Prefixes
Q (any, num) = remove bth item of a 
  (str, str) = Get all groups in a regex match
R (any, fun)* = a.reduce(b) (makes b have arity 2)
  (num, num) = range(a, b) ([a, b))
  (str, str) = Is there a regex match of pattern b in string a 
S (any) = sort in ascending order
T (str) = Titlecase
  (lst) = Transpose
  (num) = Triple
U (any) = Uninterleave
V (lst) = [x[::-1] for x in a]
W (...) = ...d c b a => [...d c b a]
X (any, any) = Cartesian product
Y (any, num) = [a].repeat(b)
Z (any, any) = zip(a, b)
^ (...) = ...d c b a => a b c d ...
_ (any) = pop / discard
a (num) = any digit non-0?
  (str) = is character uppercase?
  (lst) = are any items truthy?
b (any) = convert from binary
c (any, any)! = a in b?
d (any) = a + a 
e (num) = even?
  (str) = split on newlines
f (any) = Flatten
g (lst) = min(a)
  (scl, scl) = min(a, b)
h (any) = a[0]
i (any, num)* (except num, num) = a[b]
  (lst, lst) = [a[x] for x in b]
  (str, str) -> enclose b in a (a[0:len(a)//2] + b + a[len(a)//2:])
  (any, fun)* = Apply b on a and collect unique values. Does include the initial value.
j (any, any) = join a on b
l (num, num) = Logarithm
  (str, str) = len(a) == len(b)
  (str, num)* = len(a) == b
  (any, fun)* = apply until a previous value is repeated, collecting intermediate results
m () = context variable m
n () = context variable n
o (any, num) = Overlapping slices of a of length b
  (any) = Overlapping slices of a of length 2
p (any, any) = Prepend
q (any) = Quotify
r (any, any, any) = s/b/c
s (any, any) = split a on b
t (any) = a[-1]
u (any) = uniquify
v (any, any) = vectorised or (tbd what happens with scl, scl)
w (any) = [a]
x () = call the current function (or top level program)
y (any, any, any) = Transliterate
z (any, any) = Transpose with filler (the thing jelly has)