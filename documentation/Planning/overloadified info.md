F, G, H = monadic functions
f, g, h = dyadic functions
á¸Ÿ, Ä¡, á¸£ = any arity

Syntax

- [x] Î»   NA  =   Lambda opener
- [x] Æ›   NA  =   Mapping lambda opener
- [x] Î›   NA  =   Filtering lambda opener
- [x] Ê   NA  =   Reduction lambda opener
- [x] á»¿   NA  =   Sorting lambda opener
- [x] Î¾   NA  =   Lambda with arity -1
- [ ] â¾   NA  =   Eager map opener

Modifiers

- [x] âˆ¥   F<any>, G<any>  =   Parallel apply. Execute F and G on two different stacks, pop the arguments G used, and push the result of F then G.
- [x] âˆ¦   F<any>, G<any>  =   Parallel apply and wrap. Equivalent to âˆ¥FG;
- [ ] âˆº   F<1>, G<1>  = Correspond. Given stack of ... x y, results in ... G(y) F(x)
- [ ]     F<2+>, G<2+>    =   Given stack of ... a b c d, results in ... G(d, c) F(b, a)
- [ ] âœ   F<1>    =   Group By Element. Group items in the top of stack by application of function F
- [ ]     F<2+>   = Window Reduce. Reduce overlapping (arity) windows by function F.
- [ ] â‘´   NA  =   Next element as lambda
- [ ] â‘µ   NA  =   Next 2 elements as lambda
- [ ] â‘¶   NA  =   Next 3 elements as lambda
- [ ] â‘·   NA  =   Next 4 elements as lambda
- [ ] â‚   F<any>  =   Both. Apply F to both the top of stack (or however many arguments), and under stack (or however many arguments under the arity). Effectively ... F(top - arity, top - arity * 2) F(top -> top - arity)
- [ ] ğŸœ³   F<2+>, G<2+> = G(F(x, y), y)
- [ ] â–¥   F<1>    =   Map over columns. To each column of top, apply F.
- [ ]     F<2+>   =   Reduce over columns. To each column of top, reduce by F.
- [ ] â–¦   F<2>    =   Outer Product. [F(under, x) for x in top]
- [ ] Â¨   F<1>    =   Map. Apply F to each item in top
- [ ]     F<2+>    =   Zip with. Apply F to each item in zip(top, under, ...[kicker, ...])


Elements

Types = num (number) str (string) lst (list) fun (function) any (any value) qnt (quantum value)
* after a pair of types indicates type switching occurs
! after a pair of types inicates depth switching (deeper on left, shallower on right)
A lack of a lst overload indicates auto-vectorisation.

a = lhs
b = rhs

- [ ] âŠ (any) = [a.count(_) for _ in a]
- [ ] Î¶ () = When entering a lambda, store the popped value in this
- [ ] Î³ () = When entering a lambda, retrieve top of outer stack
- [ ] âŠ (any) = [a, b, c] => something that is a, b, and c, all at the same time
- [ ] â‹ (qnt) = create a list of all possible values the item can be
- [ ] âŸ (qnt, num) = get the nth possible value
- [ ] Ã· (num, num) = a divided by b
- [ ]   (str, num)* = split string b into chunks of size a
- [ ]   (str, str) = split a on regex b
- [ ] Ã— (num, num) = a times b
- [ ]   (str, num)* = repeat string a, b times
- [ ]   (str, str) = ring translate
- [ ] âˆ§ (any, any) = b && a (first falsey)
- [ ] âˆ¨ (any, any) = b || a (first truthy)
- [ ] Â¬ (any) = not a (truthy => 0, falsey => 1)
- [ ] Ê€ (num) = range [0, a]
- [ ]   (str) = uppercase
- [ ] Ê (num) = range [0, a)
- [ ]   (str) = lowercase
- [ ] É¾ (num) = range [1, a]
- [ ]   (str) = is character a an alphabetical (a-zA-Z) letter?
- [ ] â€¹ (num) = a - 1
- [ ]   (str) = Pad string with 0s to length nearest multiple of 8
- [ ] â€º (num) = a + 1
- [ ]   (str) = Replace spaces with 0s
- [ ] ! (num) = Factorial
- [ ]   (str) = Titlecase
- [ ] $ (any, any) = ...d c b a => d c a b
- [ ] % (num, num) = a modulo b
- [ ]   (str, any) = a.format(b) # format on %s
- [ ] & (any, any) = append b to a
- [ ] * (num, num) = a to the power of b
- [ ] + (num, num) = a + b
- [ ]   (str, num)* = str(a) + str(b)
- [ ]   (str, str) = a + b
- [ ] , (any) = Println
- [ ] - (num, num) = a - b
- [ ]   (str, num) = append b "-"s to a
- [ ]   (num, str) = prepend a "-"s to b
- [ ]   (str, str) = remove all instance of regex b in a
- [ ] : (any) = ...d c b a => d c b a a
- [ ] ; (any, any) = [a, b]
- [ ] < (num, num) = a < b
- [ ]   (str, num)* = str(a) < str(b)
- [ ]   (str, str) = a < b (lexiographically)
- [ ] = (num, num) = a == b
- [ ]   (str, num)* = str(a) == str(b)
- [ ]   (str, str) = a == b
- [ ] > (num, num) = a > b
- [ ]   (str, num)* = str(a) > str(b)
- [ ]   (str, str) = a > b (lexiographically)
- [ ] ? = push input eval'd
- [ ] @ (num, num) = |a - b|
- [ ]   (str, str) = Levenshtein distance between a and b
- [ ]   (any, fun)* = Reduce overlaps in list a by function b
- [ ] A (num) = Are all digits of a truthy?
- [ ]   (str) = Is character a vowel?
- [ ]   (lst) = Are all items in a truthy?
- [ ] B (num) = Convert a to binary (list of digits)
- [ ]   (str) = each character in a to the binary representation of its character code
- [ ] C (any, any)! = count of a in b
- [ ] D (any) = ...d c b a => d c b a a a
- [ ] E (num) = a ** 2
- [ ]   (str) = Evaluate str (think python eval)
- [ ] F (any, fun) = a.filter(b)
- [ ]   (any, non-fun)! = a.find(b)
- [ ] G (lst) = max(a)
- [ ]   (scl, scl) = max(a, b)
- [ ] H (num) = to_hex(a) (base 10 -> base 16)
- [ ]   (str) = from_hex(a) (base 16 -> base 10)
- [ ] I (any, fun)* = a.filter(x => !b(x)) (reject by)
- [ ]   (any, non-fun) = Interleave
- [ ] J (lst, lst) = a.addAll(b) (merge)
- [ ]   (num, num) = int(s"$a$b")
- [ ] K (num) = factors of a
- [ ]   (str) = is string numeric
- [ ] L (any) = length
- [ ] M (any, fun)* = a.map(b)
- [ ]   (lst, lst) = mold a to shape of b
- [ ]   (num, num) = multiplicity
- [ ]   (lst, num)* = vectorised num,num
- [ ] N (num) = -a
- [ ]   (str) = swap case
- [ ]   (fun) = First non-negative integer x where a(x) is true
- [ ] O (num) = character with corresponding character code
- [ ]   (str) = number(s) that correspond to character codes
- [ ] P (any) = Prefixes
- [ ] Q (any, num) = remove bth item of a 
- [ ]   (str, str) = Get all groups in a regex match
- [ ] R (any, fun)* = a.reduce(b) (makes b have arity 2)
- [ ]   (num, num) = range(a, b) ([a, b))
- [ ]   (str, str) = Is there a regex match of pattern b in string a 
- [ ] S (any) = sort in ascending order
- [ ] T (str) = Titlecase
- [ ]   (lst) = Transpose
- [ ]   (num) = Triple
- [ ] U (any) = Uninterleave
- [ ] V (lst) = [x[::-1] for x in a]
- [ ] W (...) = ...d c b a => [...d c b a]
- [ ] X (any, any) = Cartesian product
- [ ] Y (any, num) = [a].repeat(b)
- [ ] Z (any, any) = zip(a, b)
- [ ] ^ (...) = ...d c b a => a b c d ...
- [ ] _ (any) = pop / discard
- [ ] a (num) = any digit non-0?
- [ ]   (str) = is character uppercase?
- [ ]   (lst) = are any items truthy?
- [ ] b (any) = convert from binary
- [ ] c (any, any)! = a in b?
- [ ] d (any) = a + a 
- [ ] e (num) = even?
- [ ]   (str) = split on newlines
- [ ] f (any) = Flatten
- [ ] g (lst) = min(a)
- [ ]   (scl, scl) = min(a, b)
- [ ] h (any) = a[0]
- [ ] i (any, num)* (except num, num) = a[b]
- [ ]   (lst, lst) = [a[x] for x in b]
- [ ]   (str, str) -> enclose b in a (a[0:len(a)//2] + b + a[len(a)//2:])
- [ ]   (any, fun)* = Apply b on a and collect unique values. Does include the initial value.
- [ ] j (any, any) = join a on b
- [ ] l (num, num) = Logarithm
- [ ]   (str, str) = len(a) == len(b)
- [ ]   (str, num)* = len(a) == b
- [ ]   (any, fun)* = apply until a previous value is repeated, collecting intermediate results
- [ ] m () = context variable m
- [ ] n () = context variable n
- [ ] o (any, num) = Overlapping slices of a of length b
- [ ]   (any) = Overlapping slices of a of length 2
- [ ] p (any, any) = Prepend
- [ ] q (any) = Quotify
- [ ] r (any, any, any) = s/b/c
- [ ] s (any, any) = split a on b
- [ ] t (any) = a[-1]
- [ ] u (any) = uniquify
- [ ] v (any, any) = vectorised or (tbd what happens with scl, scl)
- [ ] w (any) = [a]
- [ ] x () = call the current function (or top level program)
- [ ] y (any, any, any) = Transliterate
- [ ] z (any, any) = Transpose with filler (the thing jelly has)
- [ ] â¨¥ (num) = a + 2
- [ ]   (str) = string length == 1
- [ ] â¨ª (num) = a - 2
- [ ]   (str) = tbd (not append two "-"s though that'd be silly even by my standards)
- [ ] Î£ (any) = sum of a 
- [ ]   (lst[at least one string]) = join on nothing and eval
- [ ] Î  (any) = product of a
- [ ] Ïƒ (any) = Cumulative sums of a
- [ ] â‡§ (any) = Grade up
- [ ] â‡© (any) = Grade down
- [ ] âˆª (any, any) = Set union
- [ ] âˆ© (any, any) = Set intersection
- [ ] âŠ (any, any) = set xor
- [ ] â¦° (any, any) = set difference
- [ ] Â« (num, num) = left bit Shift
- [ ]   (str, num)* = a padded to length b with spaces prepended
- [ ]   (str, str) = a padded to length of b with spaces prepended
- [ ] Â» (num, num) = right bit shift
- [ ]   (str, num) = a padded to length b with spaces appended
- [ ]   (str, str) = a padded to length of b with spaces appended
- [ ] Æ“ (any) = max(a), but don't pop
- [ ] É  (any) = min(a), but don't pop
- [ ] Ä  (lst, num)* = [max(x, b) for x in a]
- [ ]   (lst, lst) = [max(x, y) for (x, y) in zip(a, b)]
- [ ] Ä¡ (lst, num)* = [min(x, b) for x in a]
- [ ]   (lst, lst) = [min(x, y) for (x, y) in zip(a, b)]
- [ ] âŒˆ (num) = Ceiling
- [ ]   (str) = split on spaces
- [ ] âŒŠ (num) = Floor
- [ ]   (str) = cast to int, 0 if no numeric characters
- [ ] âŠ– (any, num)* = a[0:b]
- [ ] âŒ½ (any, num)* = a[1:b]
- [ ] Â£ (any) = set Register
- [ ] Â¥ () = push Register
- [ ] â–² (any, any) = vectorised and (tbd what happens with scl, scl)
- [ ] â†œ (...) = rotate stack left
- [ ] â† (...) = rotate stack right
- [ ] â¬³ (non-num) = rotate item left
- [ ]     (any, num) = rotate item left b times
- [ ] âŸ¿ (non-num) = rotate item right
- [ ]    (any, num) = rotate item right b times
- [ ] â‰œ (any, num, non-fun) = a[b] = c
- [ ]    (any, num, fun) = a[b] = c(a[b])
- [ ]    (any, lst[num], fun) = essentially vectorised of (any, num, fyn)
- [ ]    (lst, lst, lst) = [a[x] = y for (x, y) in zip(x, y)]
- [ ]    (str, str, str) = replace regex matches of pattern b in string a with c
- [ ]    (str, str, fun)* = replace regex matches of pattern b in string a with the result of applying c to each match
- [ ]    (rec, str, str)* = a.b = c
- [ ] â€ (any, num, any) = insert c at position b in a
- [ ]    (any, lst, any) = insert c at positions b in a
- [ ]    (any, lst[num], lst) = insert c[i] at position b[i] in a
- [ ] â—² (any) = sublists of a
- [ ] âŠ¢ (num, num) = a (base 10) in base b
- [ ]   (num, str|lst) = a in base with alphabet b
- [ ]   (lst, num) = each x in a in base b
- [ ]   (lst, lst) = each x in a in base with alphabet b
- [ ]   (str, str) = All matches of b in a
- [ ] âŠ£ (num, num) = a (in base b) in base 10
- [ ]   (num, str|lst) = a from base with alphabet b to base 10
- [ ]   (lst, num) = this, but vectorised
- [ ] É¦ (any) = a[0], but don't pop
- [ ] Êˆ (any) = a[-1], but don't pop
- [ ] á (any) = a[:-1] (because the : is on the left)
- [ ] áµ (any, num) = a[b:]
- [ ] á• (any) = a[1:] (because the : is on the right)
- [ ] Â½ (num) = a / 2
- [ ]   (str) = a split into 2 parts with roughly equal length
- [ ] Æ¶ (any) = [0, len(x))
- [ ] Æµ (any) = [1, len(x)]
- [ ] â° () = first input
- [ ] Â¹ () = second input
- [ ] Â² (num) = Square
- [ ]   (str) = a split into pairs
- [ ] Â³ (num) = cube
- [ ]   (str) = a split into chunks of length 3
- [ ] â…Ÿ (num) = 1 / x
- [ ]   (str) = a with all whitespace removed
- [ ] â€» (any) = group by consecutive values
- [ ]    (any, fun) = group by function (keep order)
- [ ] â‡„ (any) = a[::-1] reverse
- [ ] â§– (any) = permutations
- [ ] â€° (num, num) = [a // b, a % b]
- [ ] â‰› (num, num) = does b divide a?
- [ ]   (str, num)* = a + ' ' * b
- [ ]   (lst, fun)* = Remove duplicates from a by applying b to each element
- [ ]   (str, str) = span of first regex match of b in a
- [ ] â (any) = [[temp, a.count(temp)] for temp in a]
- [ ] â¦· (num) = Absolute value
- [ ]    (str) = keep alphabet characters of a
- [ ] Ï¢ (any, num) = a wrapped in chunks of length b
- [ ] â‰¤ (num, num) = a <= b
- [ ] â‰¥ (num, num) = a >= b
- [ ] â‰  (scl, scl) = a != b
- [ ] â‰¡ (any, any) = a == b (non-vec)
- [ ] â€¢ (lst, lst) = dot product
- [ ]   (num, num) = Convert a to bijective base b
- [ ]   (lst, fun) = First index of a where b is truthy
- [ ] Â± (num) = sign of a
- [ ]   (str) = tbd
- [ ] â€  (any) = lengths of consecutive groups
- [ ] â™ (any) = print without popping
- [ ] âœ’ (any) = print (not println)
- [ ] â‰“ (num) = a + reversed(a) (as number)
- [ ]   (str) = a + reversed(a)
- [ ]   (lst) = append reversed(a) to a
- [ ] Ï¾ (lst) = Â¨Î£
- [ ] â›­ (num) = a ** 10
- [ ]    (str) = Exec
- [ ]    (fun) = call function
- [ ] âŸ (any, num) = every bth element of a
- [ ] âŒ­ (num) = is a prime?
- [ ]    (str) = quote a and prepend to a
- [ ] âœ () = ...d c b a => ...d c b a b
- [ ] â¢ (num) = a % 2
- [ ]    (str) = last half of a
- [ ] â„‚ (num, num) = n choose K
- [ ]   (str, str) = are the character sets of a and b equal?
- [ ]   (str, num)* = all b-length combinations from a
- [ ]   (fun, any)* = run a on b until the result no longer changes returning all intermediate results
- [ ] âŒ¹ (lst) = List partitions of a
- [ ]    (num) = Integer partitions of a (all possible ways to sum to a)
- [ ] âš (lst) = powerset
- [ ] â†¯ (lst, fun) = sort by function
- [ ] âŠ  (lst, num) = Cartesian power
- [ ] âš… (num) = randint(0, a)
- [ ]    (str|lst) = random element from a
- [ ] Ã¦ (any) = a, a[::-1]
- [ ] â£ () = " " (space)
- [ ] Â¶ () = "\n" (newline)
- [ ] â˜… () = "*" (Asterisk)
- [ ] á‘‚ (any) = a[1:], a[0]
- [ ] âˆ» (num, num) = floor division
- [ ] âˆš (num) = sqrt(a)
- [ ] â‚¿ (scl) = is a truthy?
- [ ]   (lst) = vectorised
- [ ] â—Œ (num) = round(x) -> round half up 
- [ ] #â—Œ () = list of all inputs
- [ ] Î´ (lst) = forward differences (âŠ-)
- [ ] â˜· (lst, lst) = Partition y after truthy indices of x.
- [ ] âœ‡ (lst|str) = Edges. [x[0], x[-1]]
- [ ]    (num) = [real, complex]
- [ ] âƒ (any) = Flatten x and join on nothing
- [ ] â¶ (any, any) = trim b from both sides of a
- [ ] âŠ† (lst, lst) = is b a subset of a?
- [ ] â¨ (any) = dump items of a
- [ ] Â¤ (any) = 2Ï¢
- [ ] â˜ (lst, num) = flatten by depth
- [ ]    (lst) = flatten one layer
- [ ] êœ (lst) = keep only truthy items
- [ ] â‰ˆ (any) = all items equal?
- [ ] â‰Š (any, any) = are all items in a equal to b?
- [ ] Îº (num, num) = gcd(a, b)
- [ ]   (lst) = gcd(all items in a)
- [ ] â¬± (num) = nth item from outer stack 
- [ ]    (otherwise) = top item from outer stack...?
- [ ] Ãâ¬± (any, num > 0) = append a[0] until length b
- [ ]    (any, num < 0) = append a[-1] until length b
- [ ] â€ (any) = join on newlines
- [ ] â€ (any) = join on spaces
- [ ] â€œ (any) = join on nothing