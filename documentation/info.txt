ðŸŒ® ==> Taco
ðŸª ==> Cookie
êœ ==> Increment
à¶ž ==> à¶ž
! ==> Factorial
$ ==> Swap
% ==> Modulo | String Formatting
& ==> Append
' ==> Join Sublists on Spaces then Newlines (Element Form of ')
* ==> Exponentation | Remove Nth Letter | Trim
+ ==> Addition
, ==> Print
- ==> Subtraction
: ==> Duplicate
; ==> Pair
< ==> Less Than
= ==> Equals
> ==> Greater Than
? ==> Get Input
@ ==> Cumulative Sums
A ==> All Truthy | All() | Is Vowel?
B ==> Convert From Binary
C ==> Count
D ==> Triplicate
E ==> 2 Power | Evaluate
F ==> Filter by Function | From Base
G ==> Monadic Maximum | Dyadic Maximum | Generate From Function | Vectorised Maximum
H ==> Hexadecimal | To Hexadecimal
I ==> Interleave / Reject By Function
J ==> Merge
K ==> Factors | Is Numeric?
L ==> Length | Length of List
M ==> Map Function | Mold Lists | Multiplicity
N ==> Negation | Swap Case | First Non-Negative Integer Where Predicate is True
O ==> Ord/Chr
P ==> Prefixes
Q ==> Remove At | Regex Groups
R ==> Reduce by Function Object | Dyadic Range | Regex Match | Set Union
S ==> Sort ascending
T ==> Triple | Contains Only Alphabet | Transpose
U ==> Uninterleave
V ==> Vectorised Reverse | Complement | Title Case
W ==> Wrap
X ==> Return Statement
Y ==> List Repeat
Z ==> Zip
\ ==> Dump
^ ==> Reverse Stack
_ ==> Pop and Discard
` ==> Length of Stack
a ==> Any Truthy | Any() | Is Uppercase?
b ==> Convert To Binary
c ==> Contains
d ==> Double
e ==> Is Even / Split on Newlines
f ==> Flatten
g ==> Monadic Minimum | Dyadic Minimum | Generate From Function (Dyadic) | Vectorised Minimum
h ==> Head | First Item
i ==> Index | Collect Unique Application Values | Enclose | Read Member
j ==> Join On
k1 ==> 1000
k2 ==> 10000
k3 ==> 100000
k4 ==> 1000000
k6 ==> Hex Digits (lowercase)
kA ==> Uppercase Alphabet
kB ==> Uppercase and lowercase
kD ==> Lines
kF ==> FizzBuzz
kH ==> Hello, World!
kL ==> Lowercase and Uppercase Alphabet
kP ==> Printable Ascii
kR ==> Digits, Uppercase, Lowercase
kZ ==> Uppercase Alphabet Reversed
k^ ==> Hex Digits (uppercase)
ka ==> Lowercase Alphabet
kb ==> Buzz
kd ==> Digits
ke ==> Euler's Number
kf ==> Fizz
kg ==> Phi
kh ==> Hello World
ki ==> Pi
kl ==> Upper and Lowercase Alphabet Reversed
ko ==> Octal Digits
kp ==> Punctuation
kr ==> Digits, Lowercase, Uppercase
kz ==> Lowercase Alphabet Reversed
l ==> Length of Each Item
m ==> Get Context Variable M
n ==> Get Context Variable N
o ==> Overlap | Overlapping Slices
p ==> Prepend
q ==> Quotify | Nth Prime
r ==> Replace
s ==> Split
t ==> Tail | Last Item
u ==> Uniquify
v ==> Decrement
w ==> Wrap Singleton
x ==> Recursion | Recurse
y ==> To Base | Regex Find
z ==> Inclusive zero Range | Is Lowercase
È¦ ==> Absolute Value | Keep Alphabet Characters
á¸‚ ==> Execute lambda without popping | Evaluate as Vyxal without popping | Boolean Mask | Is 1?
ÄŠ ==> Set XOR
á¸Š ==> Divides? | Append Spaces | Remove Duplicates by Function
Ä– ==> Execute lambda | Evaluate as Vyxal | Power with base 10
á¸ž ==> Find
Ä  ==> Group by Function Result | Greatest Common Divisor | Find all overlapping regex matches
á¸¢ ==> Head Remove | Behead
Ä° ==> Drop/Zero Slice From | Collect While Unique | Complex Number
Ä¿ ==> Logarithm | Scan Fixpoint | Same Length? | Length Equals?
á¹€ ==> Modular | Matrix Multiply | Regex Full Match?
á¹„ ==> Is Prime? | Quine Cheese
È® ==> Over
á¹– ==> Permutations
á¹˜ ==> Rotate Left
á¹  ==> Vectorised Sums | Integer Division
á¹ª ==> Init
áº† ==> Wrap to Length | Predicate Slice From 0
áºŠ ==> Cartesian Product
Î¹ ==> Length 0-Range
Îº ==> Length 1-Range
È§ ==> Absolute Difference | Apply to Neighbours
á¸ƒ ==> Bit | Parity | Last Half of String
Ä‹ ==> N Choose K (Binomial Coefficient) | Character Set Equal? | Repeat Until No Change
á¸‹ ==> Dot Product | To Bijective Base | First Index Where Predicate Truthy
Ä— ==> Reciprocal | Remove Whitespace
á¸Ÿ ==> Prime Factors | Remove Alphabet
Ä¡ ==> Group By Consecutive Items
á¸£ ==> Head Extract
Å€ ==> Transliterate | Call While
á¹ ==> Mirror
á¹… ==> Palindromise
È¯ ==> Boolify
á¹— ==> List Partitions | Integer Partitions
á¹™ ==> Rotate Right
á¹¡ ==> Sort by Function Object | Partition by Numbers | Set Difference
á¹« ==> Last Extract | Tail Extract
áº‹ ==> Cartesian Power | Regex Search for Match
Æ’ ==> Partition After Truthy Indices
Î˜ ==> Zero Slice Until
Î¦ ==> Slice from 1
Â§ ==> Print without newline
áº  ==> Assign
á¸„ ==> Unique Prime Factors | Case Of
á¸¤ ==> Head Extract Under
á»Š ==> Insert
á¸¶ ==> Sort by Length | Regex Escape
á¹‚ ==> -1 Power Of | Split on Spaces
á»Œ ==> Print without popping
á¹š ==> Reverse
á¹¢ ==> Sublists
á¹¬ ==> Trim / Cumulative Reduce
â€¦ ==> Increment Twice | Vectorised Head
â‰¤ ==> Less Than Or Equal To
â‰¥ ==> Greater Than Or Equal To
â‰  ==> Not Equal
â‚Œ ==> Exactly Equals
âº ==> Powerset
â» ==> Cube | Threes
â¾ ==> Set Intersection | Flatten By Depth | Character Multiply
âˆš ==> Square Root
âˆ‘ ==> Sum
Â« ==> Bitshift Left
Â» ==> Bitshift Right
âŒ ==> Bitwise Not
âˆ´ ==> Bitwise And
âˆµ ==> Bitwise Or
âŠ» ==> Bitwise Xor
â‚€ ==> Ten
â‚ ==> Sixteen
â‚‚ ==> Twenty-six
â‚ƒ ==> Thirty-two
â‚„ ==> Sixty-four
â‚… ==> One hundred
â‚† ==> One hundred twenty-eight
â‚‡ ==> Two hundred fifty-six
â‚ˆ ==> -1
â‚‰ ==> Empty string
Â½ ==> Halve
Ê€ ==> Exclusive Zero Range | Lowercase
É¾ ==> Inclusive One Range | Uppercase
Â¯ ==> Deltas
Ã— ==> Multiplication
Ã· ==> Divide | Split
Â£ ==> Set Register
Â¥ ==> Get Register
â† ==> Rotate Stack Left
â†‘ ==> Grade Up
â†’ ==> Rotate Stack Right
â†“ ==> Grade Down
Â± ==> Sign
â€  ==> Length of Consecutive Groups
Î  ==> Product
Â¬ ==> Logical Not
âˆ§ ==> Logical And
âˆ¨ ==> Logical Or
â° ==> First Input
Â¹ ==> Second Input
Â² ==> Square | Pairs
âŒˆ ==> Ceiling
âŒŠ ==> Floor
Æ“ ==> Maximum without popping
É  ==> Minimum without popping
â€ž ==> Join on Spaces | Is Negative? (Used when not closing a string)
â€ ==> Join On Newlines | Pad Binary to Mod 8 | Context if 1
Ã° ==> Space
â‚¬ ==> Suffixes
â€œ ==> Join on Nothing | First Positive Integer | Is Alphanumeric | Insignificant?
Â¶ ==> Newline
á¶¿ ==> Bifuricate
á¶² ==> Stringify
â€¢ ==> Asterisk
â‰ˆ ==> All Equal?
#|para-apply ==> [Internal Use] Parallel Apply (Element Form)
#|minimum-by ==> [Internal Use] Minimum By (Element Form)
#|map-prefixes ==> [Internal Use] Map Prefixes (Element Form)
#|map-suffixes ==> [Internal Use] Map Suffixes (Element Form)
#|reduce-cols ==> [Internal Use] Reduce Columns (Element Form)
#|maximum-by ==> [Internal Use] Maximum By (Element Form)
#|vscan ==> [Internal Use] Vectorised Scan (Element Form)
#|para-apply-wrap ==> [Internal Use] Parallel Apply Wrap (Element Form)
#|apply-to-register ==> [Internal Use] Apply to Register (Element Form)
#|vec-dump ==> [Internal Use] Map Dump (Element Form)
#|dip ==> [Internal Use] Dip (Element Form)
#|invar ==> [Internal Use] Invariant (Element Form)
#|all-neigh ==> [Internal Use] All Neighbours (Element Form)
#Â¿ ==> Number of Inputs
#? ==> All Inputs
#C ==> Compress String Using Dictionary
#Q ==> Exit | Quit
#X ==> Loop Break
#c ==> Base-252 Compress String or Number
#v ==> [Internal Use] Vectorise (Element Form) 
#x ==> Loop Continue
#~ ==> [Internal Use] Apply Without Popping (Element Form)
#Â¤ ==> Number of Context Parameters
âˆ†< ==> Argument / Phase / Angle
âˆ†A ==> Arithmetic Mean
âˆ†C ==> Hyperbolic Cosine
âˆ†G ==> Geometric Mean
âˆ†H ==> Harmonic Mean
âˆ†I ==> Imaginary Part
âˆ†L ==> Least Common Multiple
âˆ†R ==> Real Part
âˆ†S ==> Hyperbolic Sine
âˆ†T ==> Hyperbolic Tangent
âˆ†c ==> Cosine
âˆ†q ==> Prime Exponents
âˆ†s ==> Sine
âˆ†t ==> Tangent
âˆ†á¹ª ==> Dyadic Arctangent / Dyadic Inverse Tangent
âˆ†Ä‹ ==> Arccosine / Inverse Cosine
âˆ†á¸‹ ==> Radians to Degrees
âˆ†á¸Ÿ ==> All Prime Exponents
âˆ†á¹™ ==> Degrees to Radians
âˆ†á¹¡ ==> Arcsine / Inverse Sine
âˆ†á¹« ==> Arctangent / Inverse Tangent
âˆ†á¹š ==> Principal Root Of Unity
Ã¸â¾ ==> Surround
Ãž0 ==> Zero Pad
ÃžO ==> Grid Neighbours (Wrap Around)
ÃžP ==> Set of All Primes
ÃžR ==> Reshape
ÃžT ==> Transpose Safe
Ãžh ==> Ends
Ãži ==> Multidimensional Index
Ãžo ==> Grid Neighbours
ÃžÄŠ ==> Cycle | Is Positive?
ÃžÈ® ==> Grid Neighbours (Diagonals, Wrap Around)
ÃžáºŠ ==> Cartesian Product Unsafe
ÃžÎ¹ ==> 0-Lift
ÃžÎº ==> 1-Lift
ÃžÄ‹ ==> Multi-Set XOR
Ãžá¹… ==> Multi-Set Difference
ÃžÈ¯ ==> Grid Neighbours (Diagonals)
Ãžáº  ==> Multidimensional Assignment
Ãžá»Š ==> Indices Where Truthy
Ãžá¹‚ ==> Matrix Inverse
Ãžá¹† ==> Set of Natural Numbers
Ãžá¹¬ ==> Set of Integers
Ãžâ¾ ==> Multi-Set Intersection
ÃžÃ· ==> Into N Pieces | Split Into N Pieces
áµœ ==> Scan elements to the left until a newline is found. Push a
lambda with all of the scanned elements
Ð§ ==> Turn the next four elements (whether that be a structure/modifier/element) into a lambda
áµˆ ==> Turn the next element (whether that be a structure/modifier/element) into a dyadic lambda
á¶¤ ==> Find the first index where an element is truthy
âˆ¦ ==> Parallel apply two elements to the top of the stack
and wrap the result in a list
áµž ==> Check if a function is invariant under a transformation / vertical scan
áµ ==> Map an element over the groups formed by identical items.
â¿ ==> Minimum By Element
áµ‡ ==> Apply a 2+ arity element to the stack without popping
Remove duplicates from a list by an element
á´´ ==> Apply element only to the head of list
á¶ª ==> Loop While Unique - similar to á¶¨, but doesn't collect
áµ ==> Maximum By Element
á¶³ ==> Sort By Element / Scanl
áµ‚ ==> Stash the top of the stack temporarily, and then apply
the function. Finally, push the stashed value
Ñ ==> Turn the next three elements (whether that be a structure/modifier/element) into a lambda
áµ– ==> Map an element over the prefixes of a list
Ï© ==> Turn the next two elements (whether that be a structure/modifier/element) into a lambda
á¶¨ ==> Loop and Collect While Unique
áµ˜ ==> Run func on the prev result until the result no longer changes
returning all intermediate results
Given a dyadic function, apply the function to all overlapping pairs of elements
and test if all results are equal
áµƒ ==> To each overlapping pair, reduce it by an element
Apply a dyadic element for all pairs of neighboring elements.
Count the number of truthy elements in a list under a mondaic element
á¶» ==> Given a dyadic function, zip two lists and reduce each by f
 and then check if all results are equal.
Given a monadic function, the inverse of monadic /.
Filters where the function is falsey
Â¿ ==> Pop the top of the stack, and, if it's truthy, apply a function
áµ‰ ==> Turn the next two elements (whether that be a structure/modifier/element) into a dyadic lambda
á´¿ ==> Apply a function to the register. Essentially, push
the register value to the stack, apply the function, and
then pop back into the register
á´³ ==> Turn the next four elements (whether that be a structure/modifier/element) into a dyadic lambda
â¸  ==> Turn the next element (whether that be a structure/modifier/element) into a lambda
áµ— ==> Map a function over the top of the stack, treating each iteration
as if it were a stack of items. Essentially, dump before mapping

áµ› ==> Vectorises
á¶œ ==> Reduce columns of a 2d list by a function
Map an element over suffixes
á¶  ==> Turn the next three elements (whether that be a structure/modifier/element) into a dyadic lambda
áµ’ ==> Outer product
/ ==> Reduce a list by an element
âˆ¥ ==> Parallel apply two elements to the top of the stack
áµ¡ ==> Scan a function until it reaches a fixed point
