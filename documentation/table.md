| Symbol | Name | Keywords | Arity | Vectorises | Overloads |
| --- | --- | --- | --- | --- | --- |
| `ğŸª` | Cookie | cookie | None | âŒ | cookie.
| `à¶` | à¶ | sus | None | âŒ | à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶à¶
| `Â¦` | Pipe | pipe | Some(0) | âŒ | -> |
| `áµ›` | Decrement | decr, decrement | Some(1) | âœ… | a: num -> a - 1
| `!` | Factorial | fact, factorial | Some(1) | âœ… | a: num -> a!
| `#|para-apply` | [Internal Use] Parallel Apply (Element Form) |  | None | âŒ | *a, f -> The iconic parallel apply. Use the modifier instead bingus.
| `#|minimum-by` | [Internal Use] Minimum By (Element Form) |  | None | âŒ | *a, f -> minimum of a by f. Use the modifier instead.
| `#|map-prefixes` | [Internal Use] Map Prefixes (Element Form) |  | None | âŒ | *a, f -> f applied to each prefix of a. Use the modifier instead.
| `#|map-suffixes` | [Internal Use] Map Suffixes (Element Form) |  | None | âŒ | *a, f -> f applied to each suffix of a. Use the modifier instead.
| `#|reduce-cols` | [Internal Use] Reduce Columns (Element Form) |  | None | âŒ | *a, f -> each column of a reduced by f. Use the modifier instead.
| `#|maximum-by` | [Internal Use] Maximum By (Element Form) |  | None | âŒ | *a, f -> maximum of a by f. Use the modifier instead.
| `#|vscan` | [Internal Use] Vectorised Scan (Element Form) |  | None | âŒ | *a, f -> scanl each column. Use the modifier instead.
| `#|para-apply-wrap` | [Internal Use] Parallel Apply Wrap (Element Form) |  | None | âŒ | *a, f -> The iconic parallel apply. Use the modifier instead bingus.
| `#|apply-to-register` | [Internal Use] Apply to Register (Element Form) |  | None | âŒ | *a, f -> f applied to the register. Use the modifier instead.
| `#|vec-dump` | [Internal Use] Map Dump (Element Form) |  | None | âŒ | *a, f -> f applied to each element of a, treating as a stack. Use the modifier instead.
| `#|dip` | [Internal Use] Dip (Element Form) |  | None | âŒ | *a, f -> f applied to a with a pushed back. Use the modifier instead.
| `#|invar` | [Internal Use] Invariant (Element Form) |  | None | âŒ | *a, f -> Use the áµ modifier instead.
| `#|all-neigh` | [Internal Use] All Neighbours (Element Form) |  | None | âŒ | *a, f -> f applied to each neighbour of a. Use the modifier instead.
| `#C` | Compress String Using Dictionary | compress-dict, dict-comp, compress | Some(1) | âŒ | a: str -> compress a using the dictionary
| `#X` | Loop Break | break | Some(0) | âŒ |  -> break out of the current loop
| `#v` | [Internal Use] Vectorise (Element Form)  |  | None | âŒ | *a, f -> f vectorised over however many arguments in a. It is recommended to use the modifier instead
| `#x` | Loop Continue | continue | Some(0) | âŒ |  -> continue the current loop
| `#~` | [Internal Use] Apply Without Popping (Element Form) |  | None | âŒ | *a, f -> f applied to the stack without popping items. Use the modifier instead.
| `$` | Swap | swap | None | âŒ | a, b -> b, a
| `%` | Modulo | String Formatting | mod, modulo, str-format, format, %, strfmt | Some(2) | âŒ | a: num, b: num -> a % b
| | | | | | a: str, b: any -> a.format(b) (replace %s with b if scalar value or each item in b if vector)
| `&` | Append | append | Some(2) | âŒ | a: any, b: any -> list(a) ++ [b]
| `*` | Exponentation | Remove Nth Letter | Trim | exp, **, pow, exponent, remove-letter, str-trim | Some(2) | âœ… | a: num, b: num -> a ^ b
| | | | | | a: str, b: num -> a with the bth letter removed
| | | | | | a: num, b: str -> b with the ath letter removed
| | | | | | a: str, b: str -> trim b from both sides of a
| `+` | Addition | add, +, plus | Some(2) | âœ… | a: num, b: num -> a + b
| | | | | | a: num, b: str -> a + b
| | | | | | a: str, b: num -> a + b
| | | | | | a: str, b: str -> a + b
| `,` | Print | print, puts, out, println | None | âŒ | a -> printed to stdout
| `-` | Subtraction | sub, subtract, minus, str-remove, remove, str-remove-all, remove-all | Some(2) | âœ… | a: num, b: num -> a - b
| | | | | | a: str, b: num -> a + b '-'s (or '-'s + a if b < 0)
| | | | | | a: num, b: str -> a '-'s + b (or b + '-'s if a < 0)
| | | | | | a: str, b: str -> a with b removed
| `:` | Duplicate | dup | None | âŒ | a -> a, a
| `;` | Pair | pair | Some(2) | âŒ | a, b -> [a, b]
| `<` | Less Than | lt, less, less-than, <, less?, smaller? | Some(2) | âœ… | a: num, b: num -> a < b
| | | | | | a: str, b: num -> a < str(b)
| | | | | | a: num, b: str -> str(a) < b
| | | | | | a: str, b: str -> a < b
| `=` | Equals | eq, ==, equal, same?, equals?, equal? | Some(2) | âœ… | a: any, b: any -> a == b
| `>` | Greater Than | gt, greater, greater-than, greater?, bigger? | Some(2) | âœ… | a: num, b: num -> a > b
| | | | | | a: str, b: num -> a > str(b)
| | | | | | a: num, b: str -> str(a) > b
| | | | | | a: str, b: str -> a > b
| `?` | Get Input | get-input, input, stdin, readline | Some(0) | âŒ | ->  -> input
| `A` | All Truthy | All() | Is Vowel? | all, is-vowel?, vowel? | Some(1) | âŒ | a: str -> is (a) a vowel? vectorises for strings len > 1
| | | | | | a: list -> is (a) all truthy?
| `B` | Convert From Binary | from-binary, bin->dec, bin->decimal | Some(1) | âŒ | a: num -> str(a) from binary
| | | | | | a: str -> int(a, 2)
| | | | | | a: lst -> int(a, 2), using list of digits
| `C` | Count | count | Some(2) | âŒ | a: any, b: any -> count(b in a)
| `D` | Triplicate | trip | None | âŒ | a -> [a, a, a]
| `E` | 2 Power | Evaluate | two^, two**, eval | Some(1) | âœ… | a: num -> 2^a
| | | | | | a: str -> evaluate (not execute) a
| `F` | Filter by Function | From Base | filter, keep-by, from-base, 10->b | Some(2) | âŒ | a: fun, b: lst -> Filter b by truthy results of a
| | | | | | a: lst, b: fun -> Filter a by truthy results of b
| | | | | | a: num, b: num -> a from base b to base 10
| | | | | | a: num, b: str|lst -> a from base with alphabet b to base 10
| `G` | Monadic Maximum | Dyadic Maximum | Generate From Function | Vectorised Maximum | max, maximum, generator | Some(2) | âŒ | a: lst -> Maximum of a
| | | | | | a: non-lst, b: non-lst -> Maximum of a and b
| | | | | | a: lst, b: fun -> Call b infinitely with items of a as starting values
| `H` | Hexadecimal | To Hexadecimal | hex, hexadecimal, to-hex, to-hexadecimal | Some(1) | âœ… | a: num -> a in hexadecimal
| | | | | | a: str -> a as a hexadecimal number to base 10
| `I` | Interleave / Reject By Function | interleave, reject | Some(2) | âŒ | a: lst, b: lst -> Interleave a and b
| | | | | | a: any, b: fun -> Reject elements of a by applying b
| `J` | Merge | merge | Some(2) | âŒ | a: lst, b: lst -> Merge a and b
| | | | | | a: any, b: lst -> Prepend a to b
| | | | | | a: lst, b: any -> Append b to a
| | | | | | a: num, b: num -> num(str(a) + str(b))
| | | | | | a: any, b: any -> str(a) + str(b)
| `K` | Factors | Is Numeric? | factors, divisors, is-numeric, is-num, is-number, is-num?, is-number? | Some(1) | âœ… | a: num -> Factors of a
| | | | | | a: str -> Is a numeric?
| `L` | Length | Length of List | length, len, length-of, len-of, size | Some(1) | âŒ | a: any -> Length of a
| `M` | Map Function | Mold Lists | Multiplicity | map, mold, multiplicity, times-divide | Some(2) | âŒ | a: any, b: fun -> a.map(b)
| | | | | | a: fun, b: any -> b.map(a)
| | | | | | a: lst, b: lst -> a molded to the shape of b
| | | | | | a: num, b: num -> how many times b divides a
| `N` | Negation | Swap Case | First Non-Negative Integer Where Predicate is True | neg, negate, swap-case, caseswap, first-non-negative, first-nonneg, first>-1 | Some(1) | âœ… | a: num -> -a
| | | | | | a: str -> a.swapCase()
| | | | | | a: fun -> first non-negative integer where predicate a is true
| `O` | Ord/Chr | ord, chr | Some(1) | âŒ | a: str -> ord(a)
| | | | | | a: num -> chr(a)
| `P` | Prefixes | prefixes | Some(1) | âŒ | a: lst -> Prefixes of a
| `Q` | Exit | Quit | exit, quit | None | âŒ | a -> Stop program execution
| `R` | Reduce by Function Object | Dyadic Range | Regex Match | fun-reduce, reduce, fold-by, range, a->b, regex-match?, re-match?, has-regex-match?, fold | Some(2) | âŒ | a: fun, b: any -> reduce iterable b by function a
| | | | | | a: any, b: fun -> reduce iterable a by function b
| | | | | | a: num, b: num -> the range [a, b)
| | | | | | a: str, b: num|str -> does regex pattern b match haystack a?
| `S` | Sort ascending | sort, sortasc, sort-asc | Some(1) | âŒ | a: any -> convert to list and sort ascending
| `T` | Triple | Contains Only Alphabet | Transpose | triple, alphabet?, alphabetical?, contains-only-alphabet?, contains-only-alphabetical?, transpose, flip, reverse-axes, flip-axes, permute-axes | Some(1) | âŒ | a: num -> 3 * a
| | | | | | a: str -> does a contain only alphabet characters?
| | | | | | a: any -> transpose a
| `U` | Uninterleave | uninterleave | None | âŒ | a: any -> uninterleave a
| `V` | Vectorised Reverse | Complement | Title Case | vectorised-reverse, vec-reverse, complement, titlecase, title-case | Some(1) | âŒ | a: lst -> each element of a reversed
| | | | | | a: num -> 1 - a
| | | | | | a: str -> a converted to title case
| `W` | Wrap | wrap | None | âŒ | a, b, c, ..., -> [a, b, c, ...]
| `X` | Return Statement | return, ret | None | âŒ | a -> return a
| `Y` | List Repeat | wrap-repeat | Some(2) | âŒ | a: any, b: num -> a repeated b times, wrapped in a list
| | | | | | a: num, b: any -> b repeated a times, wrapped in a list
| | | | | | a: lst|str, b: lst[num] -> a[_] repeated b[_] times, wrapped in a list
| `Z` | Zip | zip, zip-map | Some(2) | âŒ | a: lst, b: lst -> zip a and b
| | | | | | a: lst, b: fun -> [[x, b(x)] for x in a]
| | | | | | a: fun, b: lst -> [[a(x), x] for x in b]
| `\` | Dump | dump | Some(1) | âŒ | a: any -> dump all values on the stack
| `_` | Pop and Discard | pop, discard | None | âŒ | a ->
| `a` | Any Truthy | Any() | Is Uppercase? | any, is-uppercase?, is-upper?, upper? | Some(1) | âŒ | a: str -> is (a) uppercase? vectorises for strings len > 1
| | | | | | a: list -> is (a) any truthy?
| `b` | Convert To Binary | to-binary, dec->bin, decimal->bin | Some(1) | âœ… | a: num -> convert a to binary
| | | | | | a: str -> bin(ord(x) for x in a)
| `c` | Contains | contains, in | Some(2) | âŒ | a: any, b: lst -> is element a in list b?
| | | | | | a: any, b: any -> is str(b) in str(a)?
| `d` | Double | double | Some(1) | âœ… | a: num -> a * 2
| | | | | | a: str -> a + a
| `e` | Is Even / Split on Newlines | even?, even, is-even?, split-on-newlines, newline-split, split-newlines | Some(1) | âœ… | a: num -> a % 2 == 0
| | | | | | a: str -> a split on newlines
| `f` | Flatten | flatten, flat | Some(1) | âŒ | a: lst -> Flattened a
| `g` | Monadic Minimum | Dyadic Minimum | Generate From Function (Dyadic) | Vectorised Minimum | min, minimum, generator-dyadic | Some(2) | âŒ | a: lst -> Minimum of a
| | | | | | a: non-lst, b: non-lst -> Minimum of a and b
| | | | | | a: lst, b: fun -> Call b infinitely with items of a as starting values (dyadic)
| `h` | Head | First Item | head, first, first-item | Some(1) | âŒ | a: lst -> a[0]
| `i` | Index | Collect Unique Application Values | Enclose | index, at, item-at, nth-item, collect-unique, enclose | Some(2) | âŒ | a: lst, b: num -> a[b]
| | | | | | a: lst, b: lst -> a[_] for _ in b
| | | | | | a: str, b: lst -> ''.join(a[i] for i in b)
| | | | | | a: any, b: fun -> Apply b on a and collect unique values. Does include the initial value.
| | | | | | a: str, b: str -> enclose b in a (a[0:len(a)//2] + b + a[len(a)//2:])
| `j` | Join On | join-on, join, join-with, join-by | Some(2) | âŒ | a: lst, b: str|num -> a join on b
| | | | | | a: lst, b: lst -> Intersperse elements of b within a
| `l` | Length of Each Item | length-vectorised, length-vect, len-vect, len-vectorised, vec-len, vec-length, vlen | Some(1) | âŒ | a: lst -> Length of each item in a
| `m` | Get Context Variable M | get-context-m, context-m, c-var-m, ctx-m, ctx-secondary | Some(0) | âŒ | ->  -> context variable m
| `n` | Get Context Variable N | get-context-n, context-n, c-var-n, ctx-n, ctx-primary | Some(0) | âŒ | ->  -> context variable n
| `o` | Overlap | Overlapping Slices | overlap, overlaps, overlapping, overlapping-slices | Some(2) | âŒ | a: lst, b: num -> Overlapping slices of a of length b
| | | | | | a: lst|str -> Overlapping slices of a of length 2
| `p` | Prepend | prepend | Some(2) | âŒ | a: lst, b: any -> b prepended to a
| `q` | Quotify | quotify | Some(1) | âŒ | a: any -> enclose a in quotes, escape backslashes and quote marks
| `r` | Replace | replace, zip-with | Some(3) | âŒ | a: str, b: str, c: str -> replace all instances of b in a with c
| | | | | | a: fun, b: any, c: any -> reduce items in zip(b, c) by a
| `s` | Split | split | Some(2) | âŒ | a: any, b: any -> split a by b
| `t` | Tail | Last Item | tail, last, last-item | Some(1) | âŒ | a: lst -> a[-1]
| `u` | Uniquify | uniquify | Some(1) | âŒ | a: lst|str|num -> a with duplicates removed
| `w` | Wrap Singleton | wrap-singleton, enlist | Some(1) | âŒ | a -> [a]
| `x` | Recursion | Recurse | recurse | None | âŒ |  -> call the current function recursively
| `y` | To Base | to-base | Some(2) | âŒ | a: num, b: num -> a in base b
| | | | | | a: num, b: str|lst -> a in base with alphabet b
| | | | | | a: lst, b: num -> each x in a in base b
| | | | | | a: lst, b: str|lst -> each x in a in base with alphabet b
| `z` | Inclusive zero Range | Is Lowercase | inclusive-zero-range, zero->n, is-lowercase?, lowercase?, lower? | Some(1) | âœ… | a: num -> [0, 1, ..., a]
| | | | | | a: str -> is a lowercase?
| `È¦` | Absolute Value | Keep Alphabet Characters | abs, absolute-value, keep-alphabet | Some(1) | âœ… | a: num -> |a|
| | | | | | a: str -> keep alphabet characters of a
| `á¸‚` | Execute lambda without popping | Evaluate as Vyxal without popping | Boolean Mask | Is 1? | peek-call, exec-peek, boolean-mask, bool-mask, strict-boolify, is-1? | Some(1) | âŒ | a: fun -> Execute a without popping
| | | | | | a: str -> Evaluate a as Vyxal without popping
| | | | | | a: lst -> Return a boolean array with 1s at the indices in a list.
| | | | | | a: num -> Is a == 1?
| `ÄŠ` | Cycle | Is Positive? | cycle, is-positive?, positive?, >0? | Some(1) | âŒ | a: lst -> a ++ a ++ a ++ ...
| | | | | | a: num -> a > 0
| `á¸Š` | Divides? | Append Spaces | Remove Duplicates by Function | divides?, +-spaces, dedup-by | Some(2) | âŒ | a: num, b: num -> a % b == 0
| | | | | | a: str, b: num -> a + ' ' * b
| | | | | | a: num, b: str -> b + ' ' * a
| | | | | | a: lst, b: fun -> Remove duplicates from a by applying b to each element
| `Ä–` | Execute lambda | Evaluate as Vyxal | Power with base 10 | execute-lambda, evaluate-as-vyxal, power-base-10, call, @ | Some(1) | âŒ | a: fun -> Execute a
| | | | | | a: str -> Evaluate a as Vyxal
| | | | | | a: num -> 10 ** n
| `á¸` | Find | find | Some(2) | âŒ | a: any, b: any -> a.indexOf(b) (-1 if not found)
| | | | | | a: any, b: fun -> truthy indices of mapping b over a
| `Ä ` | Group by Function Result | group-by | Some(2) | âŒ | a: any, b: fun -> group a by the results of b
| | | | | | a: fun, b: any -> group b by the results of a
| `á¸¢` | Head Remove | Behead | head-remove, behead | Some(1) | âŒ | a: str -> a[1:]
| | | | | | a: any -> toList(a)[1:]
| `Ä°` | Index into Multiple | Collect While Unique | Complex Number | index-into-multiple, collect-while-unique, complex | Some(2) | âŒ | a: num, b: num -> a.real + b.real * i
| | | | | | a: any, b: lst -> `[a[item] for item in b]`
| | | | | | a: any, b: fun -> Apply b on a and collect unique values (until fixpoint). Does not include the initial value.
| `Ä¿` | Logarithm | Scan Fixpoint | Same Length? | Length Equals? | log, logarithm, scan-fixpoint, scan-fix, same-length?, same-length, length-equals?, length-equals, len-eq? | Some(2) | âœ… | a: num, b: num -> log_b(a)
| | | | | | a: fun, b: any -> apply until a previous value is repeated, collecting intermediate results
| | | | | | a: str, b: str -> a same length as b
| | | | | | a: str, b: num -> len(a) == b
| `á¹€` | Modular | Matrix Multiply | Regex Full Match? | nth-items, modular, maxtrix-multiply, mat-multiply, mat-mul, regex-full-match?, full-match? | Some(2) | âŒ | a: str|lst, b: num -> return every b-th element of a. If b is zero, mirror: prepend a to its reverse.
| | | | | | a: num, b: str|lst -> return every a-th element of b. If a is zero, mirror: append b to its reverse.
| | | | | | a: lst, b: lst -> a * b (matrix multiply)
| | | | | | a: str, b: str -> does the entirety of a match b?
| `á¹„` | Join on Nothing | First Positive Integer | Is Alphanumeric | nothing-join, concat-fold, join-on-nothing, empty-join, single-string, as-single-string, first-positive-integer, first-n>0, is-alphanumeric, is-alphanum, is-alnum | Some(1) | âŒ | a: lst -> a join on nothing
| | | | | | a: str -> is a alphanumeric?
| | | | | | a: fun -> First positive integer ([1, 2, 3, ...]) for which a returns true
| `È®` | Over | over | Some(0) | âŒ | _ -> push a copy of the second item on the stack over the first
| | | | | | a b -> a b a
| `á¹–` | Permutations | permutations, perms | Some(1) | âŒ | a: lst -> Permutations of a
| `á¹˜` | Rotate Left | abc->bca, rot-left, rotate-left | Some(1) | âŒ | a: any -> rotate left once
| `á¹ ` | Vectorised Sums | vectorised-sums, vec-sums | Some(1) | âŒ | a: lst -> sum of each element of a
| `á¹ª` | Init | init, remove-last | Some(1) | âŒ | a: lst -> a[:-1]
| | | | | | a: str -> a[:-1]
| `áº†` | Wrap to Length | Predicate Slice From 0 | wrap-length, pred-slice-0 | Some(2) | âŒ | a: lst, b: num -> a wrapped in chunks of length b
| | | | | | a: fun, b: num -> first b truthy integers where a is truthy
| `áºŠ` | Cartesian Product | cartesian-product, cartesian, cart-prod, cart | Some(2) | âŒ | a: list, b: list -> cartesian product of a and b
| `Î¹` | Length 0-Range | zero->len | Some(1) | âŒ | a: any -> `[0, 1, 2, ..., len(a)-1]`
| `Îº` | Lenght 1-Range | one->len | Some(1) | âŒ | a: any -> `[1, 2, 3, ..., len(a)]`
| `È§` | Absolute Difference | Apply to Neighbours | abs-diff, apply-to-neighbours | Some(2) | âœ… | a: num, b: num -> |a - b|
| | | | | | a: lst, b: fun -> apply b to each pair of neighbours in a [applies to windows of length 2]
| `á¸ƒ` | Bit | Parity | Last Half of String | bit, parity, str-last-half | Some(1) | âœ… | a: num -> parity of a (a % 2)
| | | | | | a: str -> last half of a
| `Ä‹` | N Choose K | Character Set Equal? | Repeat Until No Change | n-choose-k, ncr, nck, choose, char-set-equal?, char-set-eq?, until-stable | Some(2) | âœ… | a: num, b: num -> a choose b
| | | | | | a: str, b: str -> are the character sets of a and b equal?
| | | | | | a: fun, b: any -> run a on b until the result no longer changes returning all intermediate results
| `á¸‹` | Dot Product | To Bijective Base | First Index Where Predicate Truthy | dot-product, bijective-base, dot-prod, first-index-where | Some(2) | âŒ | a: lst, b: lst -> Dot product of a and b
| | | | | | a: num, b: num -> Convert a to bijective base b
| `Ä—` | Reciprocal | Remove Whitespace | reciprocal, recip, remove-whitespace, remove-space, 1/ | Some(1) | âœ… | a: num -> 1/a
| | | | | | a: str -> a with all whitespace removed
| `á¸Ÿ` | Prime Factors | Remove Non-Alphabet | prime-factors, remove-non-alphabet | Some(1) | âœ… | a: num -> prime factors of a
| | | | | | a: str -> a with all non-alphabet characters removed
| `Ä¡` | Group By Consecutive Items | group-by-consecutive | Some(1) | âŒ | a: any -> group consecutive identical items of lst(a)
| `á¸£` | Head Extract | head-extract, split-at-head | Some(1) | âŒ | a: lst|str -> Push a[0], then a[1:] onto the stack
| `Å€` | Transliterate | Call While | transliterate, call-while | Some(3) | âŒ | any a, any b, any c -> transliterate(a,b,c) (in a, replace b[0] with c[0], b[1] with c[1], b[2] with c[2], ...)
| | | | | | a: fun, b: fun, c: any -> call b on c until a(c) is falsy
| `á¹` | Mirror | mirror | Some(1) | âŒ | num a: a + reversed(a) (as number)
| | | | | | str a: a + reversed(a)
| | | | | | lst a: append reversed(a) to a
| `á¹…` | Join On Newlines | Pad Binary to Mod 8 | Context if 1 | join-newlines, newline-join, join-on-newlines, binary-pad-8, bin-pad-8, one?->context, one?->n | Some(1) | âŒ | a: lst -> a join on newlines
| | | | | | a: str -> a padded to a multiple of 8 with 0s
| | | | | | a: num -> a if a == 1 push context variable n
| `È¯` | Boolify | boolify | Some(1) | âŒ | a: any -> bool(a)
| `á¹—` | List Partitions | Integer Partitions | list-partitions, list-parts, integer-partitions, int-partitions, int-parts | Some(1) | âŒ | a: lst -> List partitions of a
| | | | | | a: num -> Integer partitions of a (all possible ways to sum to a)
| `á¹™` | Rotate Right | abc->cab, rot-right, rotate-right | Some(1) | âŒ | a: any -> rotate right once
| `á¹¡` | Sort by Function Object | Partition by Numbers | sort-by, sortby, sort-by-fun, sortbyfun, sort-fun, sortfun, partition-by | Some(2) | âŒ | a: fun, b: any -> sort iterable b by function a
| | | | | | a: any, b: fun -> sort iterable a by function b
| | | | | | a: lst, b: lst[num] -> partition a into sublists of length items in b
| `á¹«` | Last Extract | last-extract, split-at-last | Some(1) | âŒ | a: lst|str -> Push a[-1], then a[:-1] onto the stack
| `áº‹` | Cartesian Power | cartesian-power | Some(2) | âŒ | a: lst, b: num -> cart_prod([a] * n)
| `Æ’` | Partition After Truthy Indices | partition-after-truthy | Some(2) | âŒ | a: lst, b: lst -> partition a after truthy indices in b
| `Î˜` | Zero Slice Until | 0>b, zero-slice, zero-slice-until, take, slice-to, lst-truncate, first-n-items, first-n | Some(2) | âŒ | a: lst, b: num -> [a[0], a[1], ..., a[b-1]]
| `Î¦` | Slice from 1 | 1->b | Some(2) | âŒ | a: lst, b: num -> a[1:b]
| | | | | | a: num, b: lst -> b[1:a]
| `Â§` | Print without newline | print-no-newline | None | âŒ | a -> printed to stdout without newline
| `áº ` | Assign | assign, assign-at, assign<>, assign<x>, a<x>=, a<x>=y, a<x>?=y, set-item, apply-at | Some(3) | âŒ | a: lst, b: num, c: non-fun -> assign c to a at the index b / a[b] = c
| | | | | | a: lst, b: num, c: fun -> a[b] c= <stack items> (augmented assignment to list)
| | | | | | a: lst, b: lst, c: lst -> assign c to a at the indices in b
| `á¸„` | Unique Prime Factors | Case Of | unique-prime-factors, case-of | Some(1) | âœ… | a: num -> unique prime factors of a
| | | | | | a: str -> case of each character of a (uppercase = 1, lowercase = 0)
| `á¸¤` | Head Extract | head-extract-swap, split-at-head-swap | Some(1) | âŒ | a: lst|str -> Push a[1:], then a[0] onto the stack
| `á»Š` | Insert | insert, insert-at | Some(3) | âŒ | a: any, b: num, c: any -> insert c at position b in a
| | | | | | a: any, b: lst, c: any -> insert c at positions b in a
| | | | | | a: any, b: lst[num], c: lst -> insert c[i] at position b[i] in a
| `á¸¶` | Sort by Length | sort-by-length, sort-by-len, order-by-length, order-by-len, length-sort, len-sort | Some(1) | âŒ | a: lst -> sort a by length
| `á¹‚` | Bit Length | Matrix Inverse | bit-length, matrix-inverse | Some(1) | âœ… | a: num -> bit length of a
| | | | | | a: lst[lst] -> matrix inverse of a
| `á»Œ` | Print without popping | print-no-pop | None | âŒ | a -> printed to stdout without popping
| `á¹š` | Reverse | reverse | Some(1) | âŒ | a: any -> reverse a
| `á¹¢` | Sublists | sublists | Some(1) | âŒ | a: lst -> sublists of a
| `á¹¬` | Trim / Cumulative Reduce | trim, scanl, cumulative-reduce | Some(2) | âŒ | a: any, b: any -> Trim all elements of b from both sides of a.
| | | | | | a: fun, b: any -> cumulative reduce b by function a
| `â€¦` | Increment Twice | Vectorised Head | incr-twice, vec-head | Some(1) | âŒ | a: num -> a + 2
| | | | | | a: lst -> [x[0] for x in a]
| `â‰¤` | Less Than Or Equal To | le, less-than-or-equal-to | Some(2) | âœ… | a: num, b: num -> a <= b
| | | | | | a: str, b: num -> a <= str(b)
| | | | | | a: num, b: str -> str(a) <= b
| | | | | | a: str, b: str -> a <= b
| `â‰¥` | Greater Than Or Equal To | ge, greater-than-or-equal-to | Some(2) | âœ… | a: num, b: num -> a >= b
| | | | | | a: str, b: num -> a >= str(b)
| | | | | | a: num, b: str -> str(a) >= b
| | | | | | a: str, b: str -> a >= b
| `â‰ ` | Not Equal | not-equal, =n't | Some(2) | âŒ | a: any, b: any -> a !== b (non-vectorising)
| `â‚Œ` | Exactly Equals | ===, exactly-equal, strictly-equal? | Some(2) | âŒ | a: any, b: any -> a === b (non-vectorising)
| `âº` | Square | Pairs | square, pairs | Some(1) | âœ… | a: num -> a ** 2
| | | | | | a: str -> a split into pairs
| `â»` | Cube | Threes | cube, threes | Some(1) | âœ… | a: num -> a ** 3
| | | | | | a: str -> a split into chunks of length 3
| `â¾` | Surround | Character Multiply | surround, character-multiply | Some(2) | âŒ | a: num, b: str -> each character in b repeated a times
| | | | | | a: any, b: any -> a prepended and appended to b
| `âˆš` | Square Root | sqrt, square-root | Some(1) | âœ… | a: num -> sqrt(a)
| `âˆ‘` | Sum | sum, /+, +/ | Some(1) | âŒ | a: lst -> sum of a
| `Â«` | Bitshift Left | bitwise-left-shift, left-shift | Some(2) | âœ… | a: num, b: num -> a << b
| `Â»` | Bitshift Right | bitwise-right-shift, right-shift | Some(2) | âœ… | a: num, b: num -> a >> b
| `âŒ` | Bitwise Not | bitwise-not | Some(1) | âœ… | a: num -> ~a
| `âˆ´` | Bitwise And | bitwise-and | Some(2) | âœ… | a: num, b: num -> a & b
| `âˆµ` | Bitwise Or | bitwise-or | Some(2) | âœ… | a: num, b: num -> a | b
| `âŠ»` | Bitwise Xor | bitwise-xor | Some(2) | âœ… | a: num, b: num -> a ^ b
| `â‚€` | Ten | ten | Some(0) | âŒ | -> 10
| `â‚` | Sixteen | sixteen | Some(0) | âŒ | -> 16
| `â‚‚` | Twenty-six | twenty-six | Some(0) | âŒ | -> 26
| `â‚ƒ` | Thirty-two | thirty-two | Some(0) | âŒ | -> 32
| `â‚„` | Sixty-four | sixty-four | Some(0) | âŒ | -> 64
| `â‚…` | One hundred | one-hundred | Some(0) | âŒ | -> 100
| `â‚†` | One hundred twenty-eight | one-hundred-twenty-eight | Some(0) | âŒ | -> 128
| `â‚‡` | Two hundred fifty-six | two-hundred-fifty-six | Some(0) | âŒ | -> 256
| `â‚ˆ` | Alphabet | alphabet, a-z | Some(0) | âŒ | -> "abcdefghijklmnopqrstuvwxyz"
| `â‚‰` | Empty array | empty-list, nil-list, new-list | Some(0) | âŒ | -> []
| `ÃT` | Transpose Safe | transpose-safe | Some(1) | âŒ | a: any -> transpose a
| `Â½` | Halve | halve | Some(1) | âœ… | a: num -> a / 2
| | | | | | a: str -> a split into two pieces
| `Ê€` | Exclusive Zero Range | Lowercase | 0->n, zero-range, lowered-range, to-lower, lower, lowercase | Some(1) | âœ… | a: num -> [0..a)
| | | | | | a: str -> a.lower()
| `É¾` | Inclusive One Range | Uppercase | one->n, one-range, to-upper, upper, uppercase | Some(1) | âœ… | a: num -> [1..a]
| | | | | | a: str -> a.upper()
| `Â¯` | Deltas | deltas | Some(1) | âŒ | a: lst -> forward-differences of a
| `Ã—` | Multiplication | mul, multiply, times, str-repeat, *, ring-trans | Some(2) | âœ… | a: num, b: num -> a * b
| | | | | | a: num, b: str -> b repeated a times
| | | | | | a: str, b: num -> a repeated b times
| | | | | | a: str, b: str -> ring translate a according to b
| `Ã·` | Divide | Split | divide, div, str-split | Some(2) | âœ… | a: num, b: num -> a / b
| | | | | | a: str, b: str -> Split a on the regex b
| `Â£` | Set Register | set-register, ->register, set-reg, ->reg | Some(1) | âŒ | a: any -> register = a
| `Â¥` | Get Register | get-register, get-reg, register, <-register, <-reg | None | âŒ |  -> push the value of the register
| `â†` | Rotate Stack Left | rotate-stack-left | None | âŒ |  -> rotate the entire stack left once
| `â†‘` | Grade Up | grade-up | Some(1) | âŒ | a: any -> indices that will sort a
| `â†’` | Rotate Stack Right | rotate-stack-right | None | âŒ |  -> rotate the entire stack right once
| `â†“` | Grade Down | grade-down | Some(1) | âŒ | a: any -> indices that will reverse-sort a
| `Â±` | Sign | sign | Some(1) | âœ… | a: num -> sign of a
| `â€ ` | Length of Consecutive Groups | len-consecutive, gvl, gavel | Some(1) | âŒ | a: any -> lengths of consecutive groups of a
| `Î ` | Product | product, prod | Some(1) | âŒ | a: lst -> product of a
| `Â¬` | Logical Not | non-vec-not, non-vec-logical-not | Some(1) | âŒ | a: any -> !a
| `âˆ§` | Logical And | and, logical-and | Some(2) | âœ… | a: any, b: any -> a && b
| `âˆ¨` | Logical Or | or, logical-or | Some(2) | âœ… | a: any, b: any -> a || b
| `â°` | First Input | first-input, input-0 | Some(0) | âŒ | The first input to the program
| `Â¹` | Second Input | second-input, input-1 | Some(0) | âŒ | The second input to the program
| `Â²` | Third Input | third-input, input-2 | Some(0) | âŒ | The third input to the program
| `âŒˆ` | Ceiling | ceiling, ceil | Some(1) | âœ… | a: num -> ceil(a)
| `âŒŠ` | Floor | floor | Some(1) | âœ… | a: num -> floor(a)
| `Æ“` | Maximum without popping | max-no-pop | Some(1) | âŒ | a: lst -> max(a) without popping a
| `É ` | Minimum without popping | min-no-pop | Some(1) | âŒ | a: lst -> min(a) without popping a
| `Ã°` | Space | space | Some(0) | âŒ | ->  
| `â‚¬` | Suffixes | suffixes | Some(1) | âŒ | a: lst -> Suffixes of a
| `Â¶` | Newline | newline | Some(0) | âŒ | -> 

| `á¶¿` | Cartesian Product Unsafe | cartesian-product-unsafe, cartesian-unsafe, cart-prod-unsafe, cart-unsafe | Some(2) | âŒ | a: list, b: list -> cartesian product of a and b in the standard order, but without accounting for infinite lists
| `á¶²` | Stringify | to-string, stringify, str | Some(1) | âŒ | a: any -> str(a)
| `â€¢` | Asterisk | asterisk | Some(0) | âŒ | -> *
| `â‰ˆ` | All Equal? | all-equal, all-equal? | Some(1) | âŒ | a: lst -> are all elements of a equal?
| `êœ` | Increment | incr, increment | Some(1) | âœ… | a: num -> a + 1
