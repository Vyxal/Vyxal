
# Information Tables

## Elements

| Symbol | Trigraph |  Name | Keywords | Arity | Vectorises | Overloads |
 --- | --- | --- | --- | --- | --- | --- |
 <code>üåÆ</code> |  | Taco | `taco` | NA | :x: | <code>very funky</code>
 <code>üç™</code> |  | Cookie | `cookie` | NA | :x: | <code>cookie.</code>
 <code>‡∂û</code> |  | ‡∂û | `sus` | NA | :x: | <code>‡∂û</code>
 <code>!</code> |  | Factorial | `fact`, `factorial` | 1 | :white_check_mark: | <code>a: num </code> => <code> a!</code>
 <code>$</code> |  | Swap | `swap` | NA | :x: | <code>a, b </code> => <code> b, a</code>
 <code>%</code> |  | Modulo \| String Formatting | `mod`, `modulo`, `str-format`, `format`, `%`, `strfmt` | 2 | :x: | <code>a: num, b: num </code> => <code> a % b</code><br><code>a: str, b: any </code> => <code> a.format(b) (replace %s with b if scalar value or each item in b if vector)</code>
 <code>&</code> |  | Append | `append` | 2 | :x: | <code>a: any, b: any </code> => <code> list(a) ++ [b]</code>
 <code>'</code> |  | Join Sublists on Spaces then Newlines (Element Form of ') | `join-sublists`, `join-sublists-on-spaces-then-newlines`, `grid` | 1 | :x: | <code>a: lst </code> => <code> sublists of a joined on spaces then that joined on newlines</code>
 <code>*</code> |  | Exponentation \| Remove Nth Letter \| Trim | `exp`, `**`, `pow`, `exponent`, `remove-letter`, `str-trim` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a ^ b</code><br><code>a: str, b: num </code> => <code> a with the bth letter removed</code><br><code>a: num, b: str </code> => <code> b with the ath letter removed</code><br><code>a: str, b: str </code> => <code> trim b from both sides of a</code>
 <code>+</code> |  | Addition | `add`, `+`, `plus` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a + b</code><br><code>a: num, b: str </code> => <code> a + b</code><br><code>a: str, b: num </code> => <code> a + b</code><br><code>a: str, b: str </code> => <code> a + b</code>
 <code>,</code> |  | Print | `print`, `puts`, `out`, `println` | NA | :x: | <code>a </code> => <code> printed to stdout</code>
 <code>-</code> |  | Subtraction | `sub`, `subtract`, `minus`, `str-remove`, `str-remove-all`, `remove-all` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a - b</code><br><code>a: str, b: num </code> => <code> a + b '-'s (or '-'s + a if b < 0)</code><br><code>a: num, b: str </code> => <code> a '-'s + b (or b + '-'s if a < 0)</code><br><code>a: str, b: str </code> => <code> a with b removed</code>
 <code>:</code> |  | Duplicate | `dup` | NA | :x: | <code>a </code> => <code> a, a</code>
 <code>;</code> |  | Pair | `pair` | 2 | :x: | <code>a, b </code> => <code> [a, b]</code>
 <code><</code> |  | Less Than | `lt`, `less`, `less-than`, `<`, `less?`, `smaller?` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a < b</code><br><code>a: str, b: num </code> => <code> a < str(b)</code><br><code>a: num, b: str </code> => <code> str(a) < b</code><br><code>a: str, b: str </code> => <code> a < b</code>
 <code>=</code> |  | Equals | `eq`, `==`, `equal`, `same?`, `equals?`, `equal?` | 2 | :white_check_mark: | <code>a: any, b: any </code> => <code> a == b</code>
 <code>></code> |  | Greater Than | `gt`, `greater`, `greater-than`, `greater?`, `bigger?` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a > b</code><br><code>a: str, b: num </code> => <code> a > str(b)</code><br><code>a: num, b: str </code> => <code> str(a) > b</code><br><code>a: str, b: str </code> => <code> a > b</code>
 <code>?</code> |  | Get Input | `get-input`, `input`, `stdin`, `readline` | 0 | :x: | <code></code> => <code>  -> input</code>
 <code>@</code> |  | Cumulative Sums | `cumulative-sums`, `cumsums`, `cumsum`, `cum-sum`, `-_-` | 1 | :x: | <code>a: lst </code> => <code> cumulative sums of a</code>
 <code>A</code> |  | All Truthy \| All() \| Is Vowel? | `all`, `is-vowel?`, `vowel?` | 1 | :x: | <code>a: str </code> => <code> is (a) a vowel? vectorises for strings len > 1</code><br><code>a: list </code> => <code> is (a) all truthy?</code>
 <code>B</code> |  | Convert From Binary | `from-binary`, `bin->dec`, `bin->decimal` | 1 | :x: | <code>a: num </code> => <code> str(a) from binary</code><br><code>a: str </code> => <code> int(a, 2)</code><br><code>a: lst </code> => <code> int(a, 2), using list of digits</code>
 <code>C</code> |  | Count | `count` | 2 | :x: | <code>a: any, b: any </code> => <code> count(b in a)</code>
 <code>D</code> |  | Triplicate | `trip` | NA | :x: | <code>a </code> => <code> [a, a, a]</code>
 <code>E</code> |  | 2 Power \| Evaluate | `two^`, `two**`, `eval` | 1 | :white_check_mark: | <code>a: num </code> => <code> 2^a</code><br><code>a: str </code> => <code> evaluate (not execute) a</code>
 <code>F</code> |  | Filter by Function \| From Base | `filter`, `keep-by`, `from-base`, `10->b` | 2 | :x: | <code>a: fun, b: lst </code> => <code> Filter b by truthy results of a</code><br><code>a: lst, b: fun </code> => <code> Filter a by truthy results of b</code><br><code>a: num, b: num </code> => <code> a from base b to base 10</code><br><code>a: num, b: str|lst </code> => <code> a from base with alphabet b to base 10</code>
 <code>G</code> |  | Monadic Maximum \| Dyadic Maximum \| Generate From Function \| Vectorised Maximum | `max`, `maximum`, `generator` | 2 | :x: | <code>a: lst </code> => <code> Maximum of a</code><br><code>a: non-lst, b: non-lst </code> => <code> Maximum of a and b</code><br><code>a: lst, b: fun </code> => <code> Call b infinitely with items of a as starting values</code>
 <code>H</code> |  | Hexadecimal \| To Hexadecimal | `hex`, `hexadecimal`, `to-hex`, `to-hexadecimal` | 1 | :white_check_mark: | <code>a: num </code> => <code> a in hexadecimal</code><br><code>a: str </code> => <code> a as a hexadecimal number to base 10</code>
 <code>I</code> |  | Interleave / Reject By Function | `interleave`, `reject` | 2 | :x: | <code>a: lst, b: lst </code> => <code> Interleave a and b</code><br><code>a: any, b: fun </code> => <code> Reject elements of a by applying b</code>
 <code>J</code> |  | Merge | `merge` | 2 | :x: | <code>a: lst, b: lst </code> => <code> Merge a and b</code><br><code>a: any, b: lst </code> => <code> Prepend a to b</code><br><code>a: lst, b: any </code> => <code> Append b to a</code><br><code>a: num, b: num </code> => <code> num(str(a) + str(b))</code><br><code>a: any, b: any </code> => <code> str(a) + str(b)</code>
 <code>K</code> |  | Factors \| Is Numeric? | `factors`, `divisors`, `is-numeric`, `is-num`, `is-number`, `is-num?`, `is-number?` | 1 | :white_check_mark: | <code>a: num </code> => <code> Factors of a</code><br><code>a: str </code> => <code> Is a numeric?</code>
 <code>L</code> |  | Length \| Length of List | `length`, `len`, `length-of`, `len-of`, `size` | 1 | :x: | <code>a: any </code> => <code> Length of a</code>
 <code>M</code> |  | Map Function \| Mold Lists \| Multiplicity | `map`, `mold`, `multiplicity`, `times-divide`, `re-match`, `regex-match` | 2 | :x: | <code>a: any, b: fun </code> => <code> a.map(b)</code><br><code>a: fun, b: any </code> => <code> b.map(a)</code><br><code>a: lst, b: lst </code> => <code> a molded to the shape of b</code><br><code>a: num, b: num </code> => <code> how many times b divides a</code><br><code>a: str, b: str </code> => <code> regex match of b in a</code><br><code>a: list, b: str </code> => <code> regex match of b of each element of a</code><br><code>a: str, b: list </code> => <code> regex match of each element of b in a</code>
 <code>N</code> |  | Negation \| Swap Case \| First Non-Negative Integer Where Predicate is True | `neg`, `negate`, `swap-case`, `caseswap`, `first-non-negative`, `first-nonneg`, `first>-1` | 1 | :white_check_mark: | <code>a: num </code> => <code> -a</code><br><code>a: str </code> => <code> a.swapCase()</code><br><code>a: fun </code> => <code> first non-negative integer where predicate a is true</code>
 <code>O</code> |  | Ord/Chr | `ord`, `chr` | 1 | :x: | <code>a: str </code> => <code> ord(a)</code><br><code>a: num </code> => <code> chr(a)</code>
 <code>P</code> |  | Prefixes | `prefixes` | 1 | :x: | <code>a: lst </code> => <code> Prefixes of a</code>
 <code>Q</code> |  | Remove At \| Regex Groups | `remove-at`, `re-groups`, `regex-groups` | 2 | :x: | <code>a: lst, b: num </code> => <code> a with bth element removed</code><br><code>a: str, b: str </code> => <code> regex groups of a with regex b</code>
 <code>R</code> |  | Reduce by Function Object \| Dyadic Range \| Regex Match \| Set Union | `fun-reduce`, `reduce`, `fold-by`, `range`, `a->b`, `regex-match?`, `re-match?`, `has-regex-match?`, `fold`, `union`, `to` | 2 | :x: | <code>a: fun, b: any </code> => <code> reduce iterable b by function a</code><br><code>a: any, b: fun </code> => <code> reduce iterable a by function b</code><br><code>a: num, b: num </code> => <code> the range [a, b)</code><br><code>a: str, b: num|str </code> => <code> does regex pattern b match haystack a?</code><br><code>a: lst, b: lst </code> => <code> union of a and b</code>
 <code>S</code> |  | Sort ascending | `sort`, `sortasc`, `sort-asc` | 1 | :x: | <code>a: any </code> => <code> convert to list and sort ascending</code>
 <code>T</code> |  | Triple \| Contains Only Alphabet \| Transpose | `triple`, `alphabet?`, `alphabetical?`, `contains-only-alphabet?`, `contains-only-alphabetical?`, `transpose`, `flip`, `reverse-axes`, `flip-axes`, `permute-axes` | 1 | :x: | <code>a: num </code> => <code> 3 * a</code><br><code>a: str </code> => <code> does a contain only alphabet characters?</code><br><code>a: any </code> => <code> transpose a</code>
 <code>U</code> |  | Uninterleave | `uninterleave` | NA | :x: | <code>a: any </code> => <code> uninterleave a</code>
 <code>V</code> |  | Vectorised Reverse \| Complement \| Title Case | `vectorised-reverse`, `vec-reverse`, `complement`, `titlecase`, `title-case` | 1 | :x: | <code>a: lst </code> => <code> each element of a reversed</code><br><code>a: num </code> => <code> 1 - a</code><br><code>a: str </code> => <code> a converted to title case</code>
 <code>W</code> |  | Wrap | `wrap` | NA | :x: | <code>a, b, c, ..., </code> => <code> [a, b, c, ...]</code>
 <code>X</code> |  | Return Statement | `return`, `ret` | NA | :x: | <code>a </code> => <code> return a</code>
 <code>Y</code> |  | List Repeat | `wrap-repeat` | 2 | :x: | <code>a: any, b: num </code> => <code> a repeated b times, wrapped in a list</code><br><code>a: num, b: any </code> => <code> b repeated a times, wrapped in a list</code><br><code>a: lst|str, b: lst[num] </code> => <code> a[_] repeated b[_] times, wrapped in a list</code>
 <code>Z</code> |  | Zip | `zip`, `zip-map` | 2 | :x: | <code>a: lst, b: lst </code> => <code> zip a and b</code><br><code>a: lst, b: fun </code> => <code> [[x, b(x)] for x in a]</code><br><code>a: fun, b: lst </code> => <code> [[a(x), x] for x in b]</code>
 <code>\\</code> |  | Dump | `dump` | 1 | :x: | <code>a: any </code> => <code> dump all values on the stack</code>
 <code>^</code> |  | Reverse Stack | `reverse-stack`, `rev-stack` | NA | :x: | <code> </code> => <code> reverse the stack</code>
 <code>_</code> |  | Pop and Discard | `pop`, `discard` | NA | :x: | <code>a </code> => <code></code>
 <code>`</code> |  | Length of Stack | `length-of-stack`, `stack-length`, `stack-len` | NA | :x: | <code> </code> => <code> push the length of the stack</code>
 <code>a</code> |  | Any Truthy \| Any() \| Is Uppercase? | `any`, `is-uppercase?`, `is-upper?`, `upper?` | 1 | :x: | <code>a: str </code> => <code> is (a) uppercase? vectorises for strings len > 1</code><br><code>a: list </code> => <code> is (a) any truthy?</code>
 <code>b</code> |  | Convert To Binary | `to-binary`, `dec->bin`, `decimal->bin` | 1 | :white_check_mark: | <code>a: num </code> => <code> convert a to binary</code><br><code>a: str </code> => <code> bin(ord(x) for x in a)</code>
 <code>c</code> |  | Contains | `contains`, `in` | 2 | :x: | <code>a: any, b: lst </code> => <code> is element a in list b?</code><br><code>a: any, b: any </code> => <code> is str(b) in str(a)?</code>
 <code>d</code> |  | Double | `double` | 1 | :white_check_mark: | <code>a: num </code> => <code> a * 2</code><br><code>a: str </code> => <code> a + a</code>
 <code>e</code> |  | Is Even / Split on Newlines | `even?`, `even`, `is-even?`, `split-on-newlines`, `newline-split`, `split-newlines` | 1 | :white_check_mark: | <code>a: num </code> => <code> a % 2 == 0</code><br><code>a: str </code> => <code> a split on newlines</code>
 <code>f</code> |  | Flatten | `flatten`, `flat` | 1 | :x: | <code>a: lst </code> => <code> Flattened a</code>
 <code>g</code> |  | Monadic Minimum \| Dyadic Minimum \| Generate From Function (Dyadic) \| Vectorised Minimum | `min`, `minimum`, `generator-dyadic` | 2 | :x: | <code>a: lst </code> => <code> Minimum of a</code><br><code>a: non-lst, b: non-lst </code> => <code> Minimum of a and b</code><br><code>a: lst, b: fun </code> => <code> Call b infinitely with items of a as starting values (dyadic)</code>
 <code>h</code> |  | Head \| First Item | `head`, `first`, `first-item` | 1 | :x: | <code>a: lst </code> => <code> a[0]</code>
 <code>i</code> |  | Index \| Collect Unique Application Values \| Enclose \| Read Member | `index`, `at`, `item-at`, `nth-item`, `collect-unique`, `enclose`, `@<=` | 2 | :x: | <code>a: lst, b: num </code> => <code> a[b]</code><br><code>a: lst, b: lst </code> => <code> a[_] for _ in b</code><br><code>a: str, b: lst[num] </code> => <code> ''.join(a[i] for i in b)</code><br><code>a: str, b: lst[any] </code> => <code> x[a] for x in b</code><br><code>a: lst, b: str </code> => <code> x[b] for x in a</code><br><code>a: any, b: fun </code> => <code> Apply b on a and collect unique values. Does include the initial value.</code><br><code>a: str, b: str </code> => <code> enclose b in a (a[0:len(a)//2] + b + a[len(a)//2:])</code><br><code>a: rec, b: str </code> => <code> get member b of a</code><br><code>a: str, b: rec </code> => <code> get member a of b</code>
 <code>j</code> |  | Join On | `join-on`, `join`, `join-with`, `join-by` | 2 | :x: | <code>a: lst, b: str|num </code> => <code> a join on b</code><br><code>a: lst, b: lst </code> => <code> Intersperse elements of b within a</code>
 <code>k1</code> |  | 1000 | `one-thousand`, `l000`, `lk` | 0 | :x: | <code></code> => <code> 1000</code>
 <code>k2</code> |  | 10000 | `ten-thousand`, `l0000`, `l0k` | 0 | :x: | <code></code> => <code> 10000</code>
 <code>k3</code> |  | 100000 | `one-hundered-thousand`, `l00000`, `l00k` | 0 | :x: | <code></code> => <code> 100000</code>
 <code>k4</code> |  | 1000000 | `one-million`, `l000000`, `l000k`, `lm` | 0 | :x: | <code></code> => <code> 1000000</code>
 <code>k6</code> |  | Hex Digits (lowercase) | `hex-digits`, `hex-digs`, `hex-lowercase`, `hex-lower`, `hex-l`, `hex-lc` | 0 | :x: | <code></code> => <code> "0123456789abcdef"</code>
 <code>kA</code> |  | Uppercase Alphabet | `uppercase-alphabet`, `uppercase-alpha`, `A->Z`, `A-Z`, `amazon` | 0 | :x: | <code></code> => <code> "ABCDEFGHIJKLMNOPQRSTUVWXYZ"</code>
 <code>kB</code> |  | Uppercase and lowercase | `uppercase-and-lowercase`, `uppercase-and-lowercase-alpha`, `A->Za->z`, `A-Za-z` | 0 | :x: | <code></code> => <code> "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</code>
 <code>kD</code> |  | Lines | `lines`, `dashes`, `bars` | 0 | :x: | <code></code> => <code> "|/-\_"</code>
 <code>kF</code> |  | FizzBuzz | `fizzbuzz`, `FB` | 0 | :x: | <code></code> => <code> "FizzBuzz"</code>
 <code>kH</code> |  | Hello, World! | `hello-world!`, `HW!` | 0 | :x: | <code></code> => <code> "Hello, World!"</code>
 <code>kL</code> |  | Lowercase and Uppercase Alphabet | `lowercase-and-uppercase-alphabet`, `lowercase-and-uppercase-alpha`, `a->zA->Z`, `a-zA-Z` | 0 | :x: | <code></code> => <code> "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</code>
 <code>kP</code> |  | Printable Ascii | `printable-ascii`, `all-ascii` | 0 | :x: | <code></code> => <code> All of printable ascci. That excludes newline</code>
 <code>kR</code> |  | Digits, Uppercase, Lowercase | `digits-uppercase-lowercase`, `digs-upper-lower`, `o9AZaz`, `o-9A-Za-z` | 0 | :x: | <code></code> => <code> "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</code>
 <code>kZ</code> |  | Uppercase Alphabet Reversed | `uppercase-alphabet-reversed`, `uppercase-alpha-reversed`, `Z->A` | 0 | :x: | <code></code> => <code> "ZYXWVUTSRQPONMLKJIHGFEDCBA"</code>
 <code>k^</code> |  | Hex Digits (uppercase) | `hex-uppercase`, `hex-upper`, `hex-u`, `hex-uc` | 0 | :x: | <code></code> => <code> "0123456789ABCDEF"</code>
 <code>ka</code> |  | Lowercase Alphabet | `lowercase-alphabet`, `lowercase-alpha`, `a->z`, `a-z` | 0 | :x: | <code></code> => <code> "abcdefghijklmnopqrstuvwxyz"</code>
 <code>kb</code> |  | Buzz | `buzz`, `BUZZ` | 0 | :x: | <code></code> => <code> "Buzz"</code>
 <code>kd</code> |  | Digits | `digits`, `digs`, `o-9` | 0 | :x: | <code></code> => <code> "0123456789"</code>
 <code>ke</code> |  | Euler's Number | `euler's-number`, `euler`, `e-num` | 0 | :x: | <code></code> => <code> 2.718281828459045</code>
 <code>kf</code> |  | Fizz | `fizz`, `FIZZ` | 0 | :x: | <code></code> => <code> "Fizz"</code>
 <code>kg</code> |  | Phi | `phi`, `golden-ratio`, `golden`, `l-618033988749895` | 0 | :x: | <code></code> => <code> Literally just phi</code>
 <code>kh</code> |  | Hello World | `hello-world`, `HW` | 0 | :x: | <code></code> => <code> "Hello World"</code>
 <code>ki</code> |  | Pi | `pi`, `E-14`, `E-1415926535897` | 0 | :x: | <code></code> => <code> Literally just pi</code>
 <code>kl</code> |  | Upper and Lowercase Alphabet Reversed | `upper-and-lowercase-alphabet-reversed`, `upper-and-lowercase-alpha-reversed`, `Z->Az->a`, `Z-Az-a` | 0 | :x: | <code></code> => <code> "ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba"</code>
 <code>ko</code> |  | Octal Digits | `octal-digits`, `octal-digs`, `o-7` | 0 | :x: | <code></code> => <code> "01234567"</code>
 <code>kp</code> |  | Punctuation | `punctuation`, `punct` | 0 | :x: | <code></code> => <code> All punctuation characters</code>
 <code>kr</code> |  | Digits, Lowercase, Uppercase | `digits-lowercase-uppercase`, `digs-lower-upper`, `o9azAZ`, `o-9a-zA-Z` | 0 | :x: | <code></code> => <code> "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</code>
 <code>kz</code> |  | Lowercase Alphabet Reversed | `lowercase-alphabet-reversed`, `lowercase-alpha-reversed`, `z->a`, `nozama` | 0 | :x: | <code></code> => <code> "zyxwvutsrqponmlkjihgfedcba"</code>
 <code>l</code> |  | Length of Each Item | `length-vectorised`, `length-vect`, `len-vect`, `len-vectorised`, `vec-len`, `vec-length`, `vlen` | 1 | :x: | <code>a: lst </code> => <code> Length of each item in a</code>
 <code>m</code> |  | Get Context Variable M | `get-context-m`, `context-m`, `c-var-m`, `ctx-m`, `ctx-secondary` | 0 | :x: | <code></code> => <code> context variable m - defaults to uppercase alphabet if outside context</code>
 <code>n</code> |  | Get Context Variable N | `get-context-n`, `context-n`, `c-var-n`, `ctx-n`, `ctx-primary` | 0 | :x: | <code></code> => <code> context variable n - defaults to lowercase alphabet if outside context</code>
 <code>o</code> |  | Overlap \| Overlapping Slices | `overlap`, `overlaps`, `overlapping`, `overlapping-slices` | 2 | :x: | <code>a: lst, b: num </code> => <code> Overlapping slices of a of length b</code><br><code>a: lst|str </code> => <code> Overlapping slices of a of length 2</code>
 <code>p</code> |  | Prepend | `prepend` | 2 | :x: | <code>a: lst, b: any </code> => <code> b prepended to a</code>
 <code>q</code> |  | Quotify \| Nth Prime | `quotify`, `nth-prime`, `prime-n` | 1 | :white_check_mark: | <code>a: str </code> => <code> enclose a in quotes, escape backslashes and quote marks</code><br><code>a: num </code> => <code> nth prime</code>
 <code>r</code> |  | Replace | `replace`, `zip-with` | 3 | :x: | <code>a: str, b: str, c: str </code> => <code> replace all instances of b in a with c</code><br><code>a: fun, b: any, c: any </code> => <code> reduce items in zip(b, c) by a</code>
 <code>s</code> |  | Split | `split` | 2 | :x: | <code>a: any, b: any </code> => <code> split a by b</code>
 <code>t</code> |  | Tail \| Last Item | `tail`, `last`, `last-item` | 1 | :x: | <code>a: lst </code> => <code> a[-1]</code>
 <code>u</code> |  | Uniquify | `uniquify` | 1 | :x: | <code>a: lst|str|num </code> => <code> a with duplicates removed</code>
 <code>v</code> |  | Decrement | `decr`, `decrement` | 1 | :white_check_mark: | <code>a: num </code> => <code> a - 1</code>
 <code>w</code> |  | Wrap Singleton | `wrap-singleton`, `enlist` | 1 | :x: | <code>a </code> => <code> [a]</code>
 <code>x</code> |  | Recursion \| Recurse | `recurse` | NA | :x: | <code> </code> => <code> call the current function recursively</code>
 <code>y</code> |  | To Base \| Regex Find | `to-base`, `re-find`, `regex-find` | 2 | :x: | <code>a: num, b: num </code> => <code> a in base b</code><br><code>a: num, b: str|lst </code> => <code> a in base with alphabet b</code><br><code>a: lst, b: num </code> => <code> each x in a in base b</code><br><code>a: lst, b: str|lst </code> => <code> each x in a in base with alphabet b</code><br><code>a: str, b: str </code> => <code> All matches of b in a</code>
 <code>z</code> |  | Inclusive zero Range \| Is Lowercase | `inclusive-zero-range`, `zero->n`, `is-lowercase?`, `lowercase?`, `lower?` | 1 | :white_check_mark: | <code>a: num </code> => <code> [0, 1, ..., a]</code><br><code>a: lst[num] </code> => <code> apl-style iota from 0 to a</code><br><code>a: str </code> => <code> is a lowercase?</code>
 <code>»¶</code> | #.A | Absolute Value \| Keep Alphabet Characters | `abs`, `absolute-value`, `keep-alphabet` | 1 | :white_check_mark: | <code>a: num </code> => <code> |a|</code><br><code>a: str </code> => <code> keep alphabet characters of a</code>
 <code>·∏Ç</code> | #.B | Execute lambda without popping \| Evaluate as Vyxal without popping \| Boolean Mask \| Is 1? | `peek-call`, `exec-peek`, `boolean-mask`, `bool-mask`, `strict-boolify`, `is-1?` | 1 | :x: | <code>a: fun </code> => <code> Execute a without popping</code><br><code>a: str </code> => <code> Evaluate a as Vyxal without popping</code><br><code>a: lst </code> => <code> Return a boolean array with 1s at the indices in a list.</code><br><code>a: num </code> => <code> Is a == 1?</code>
 <code>ƒä</code> | #.C | Set XOR | `set-xor` | 2 | :x: | <code>a: lst, b: lst </code> => <code> set xor of a and b</code>
 <code>·∏ä</code> | #.D | Divides? \| Append Spaces \| Remove Duplicates by Function | `divides?`, `+-spaces`, `dedup-by`, `re-span`, `regex-span` | 2 | :x: | <code>a: num, b: num </code> => <code> a % b == 0</code><br><code>a: str, b: num </code> => <code> a + ' ' * b</code><br><code>a: num, b: str </code> => <code> b + ' ' * a</code><br><code>a: lst, b: fun </code> => <code> Remove duplicates from a by applying b to each element</code><br><code>a: str, b: str </code> => <code> span of first regex match of b in a</code>
 <code>ƒñ</code> | #.E | Execute lambda \| Evaluate as Vyxal \| Power with base 10 | `execute-lambda`, `evaluate-as-vyxal`, `power-base-10`, `call`, `@` | 1 | :x: | <code>a: fun </code> => <code> Execute a</code><br><code>a: str </code> => <code> Evaluate a as Vyxal</code><br><code>a: num </code> => <code> 10 ** n</code>
 <code>·∏û</code> | #.F | Find | `find` | 2 | :x: | <code>a: any, b: any </code> => <code> a.indexOf(b) (-1 if not found)</code><br><code>a: any, b: fun </code> => <code> truthy indices of mapping b over a</code>
 <code>ƒ†</code> | #.G | Group by Function Result \| Greatest Common Divisor \| Find all overlapping regex matches | `group-by`, `gcd`, `re-find-overlapping`, `regex-find-overlapping`, `re-find-overlap`, `regex-find-overlap` | 2 | :x: | <code>a: any, b: fun </code> => <code> group a by the results of b</code><br><code>a: fun, b: any </code> => <code> group b by the results of a</code><br><code>a: num, b: num </code> => <code> gcd(a, b)</code><br><code>a: lst[num], b: num </code> => <code> gcd of b and all elements of a</code><br><code>a: lst[num] </code> => <code> gcd of all items in a.</code><br><code>a: str, b: str </code> => <code> all overlapping regex matches of b in a (similar to `y` but with overlaps) (JVM/JS Only)</code><br><code>a: str, b: lst[str] </code> => <code> vectorised string overload of the above</code><br><code>a: lst, b: str </code> => <code> vectorised pattern overload of the above</code>
 <code>·∏¢</code> | #.H | Head Remove \| Behead | `head-remove`, `behead` | 1 | :x: | <code>a: str </code> => <code> a[1:]</code><br><code>a: any </code> => <code> toList(a)[1:]</code>
 <code>ƒ∞</code> | #.I | Drop/Zero Slice From \| Collect While Unique \| Complex Number | `drop`, `zero-slice-from`, `slice-from`, `collect-while-unique`, `complex` | 2 | :x: | <code>a: num, b: num </code> => <code> a.real + b.real * i</code><br><code>a: str|lst, b: num </code> => <code> a[b:]</code><br><code>a: lst, b: lst[num] </code> => <code> apl style drop</code><br><code>a: any, b: fun </code> => <code> Apply b on a and collect unique values (until fixpoint). Does not include the initial value.</code>
 <code>ƒø</code> | #.L | Logarithm \| Scan Fixpoint \| Same Length? \| Length Equals? | `log`, `logarithm`, `scan-fixpoint`, `scan-fix`, `same-length?`, `same-length`, `length-equals?`, `length-equals`, `len-eq?` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> log_b(a)</code><br><code>a: fun, b: any </code> => <code> apply until a previous value is repeated, collecting intermediate results</code><br><code>a: str, b: str </code> => <code> a same length as b</code><br><code>a: str, b: num </code> => <code> len(a) == b</code>
 <code>·πÄ</code> | #.M | Modular \| Matrix Multiply \| Regex Full Match? | `nth-items`, `modular`, `maxtrix-multiply`, `mat-multiply`, `mat-mul`, `regex-full-match?`, `full-match?` | 2 | :x: | <code>a: str|lst, b: num </code> => <code> return every b-th element of a. If b is zero, mirror: prepend a to its reverse.</code><br><code>a: num, b: str|lst </code> => <code> return every a-th element of b. If a is zero, mirror: append b to its reverse.</code><br><code>a: lst, b: lst </code> => <code> a * b (matrix multiply)</code><br><code>a: str, b: str </code> => <code> does the entirety of a match b?</code>
 <code>·πÑ</code> | #.N | Is Prime? \| Quine Cheese | `prime?`, `quineify` | 1 | :white_check_mark: | <code>a: num </code> => <code> is a prime?</code><br><code>a: str </code> => <code> quote a and prepend to a</code>
 <code>»Æ</code> | #.O | Over | `over` | 0 | :x: | <code>_ </code> => <code> push a copy of the second item on the stack over the first</code><br><code>a b </code> => <code> a b a</code>
 <code>·πñ</code> | #.P | Permutations | `permutations`, `perms` | 1 | :x: | <code>a: lst </code> => <code> Permutations of a</code>
 <code>·πò</code> | #.R | Rotate Left | `abc->bca`, `rot-left`, `rotate-left` | 1 | :x: | <code>a: any </code> => <code> rotate left once</code>
 <code>·π†</code> | #.S | Vectorised Sums \| Integer Division | `vectorised-sums`, `vec-sums`, `integer-division`, `int-div`, `int-rizz`, `sums` | 1 | :x: | <code>a: lst </code> => <code> sum of each element of a</code><br><code>a: num, b: num </code> => <code> a // b</code>
 <code>·π™</code> | #.T | Init | `init`, `remove-last` | 1 | :x: | <code>a: lst </code> => <code> a[:-1]</code><br><code>a: str </code> => <code> a[:-1]</code>
 <code>·∫Ü</code> | #.W | Wrap to Length \| Predicate Slice From 0 | `wrap-length`, `pred-slice-0`, `size-chunk` | 2 | :x: | <code>a: lst, b: num </code> => <code> a wrapped in chunks of length b</code><br><code>a: fun, b: num </code> => <code> first b truthy integers where a is truthy</code>
 <code>·∫ä</code> | #.X | Cartesian Product | `cartesian-product`, `cartesian`, `cart-prod`, `cart` | 2 | :x: | <code>a: list, b: list </code> => <code> cartesian product of a and b</code>
 <code>Œπ</code> |  | Length 0-Range | `zero->len` | 1 | :x: | <code>a: any </code> => <code> `[0, 1, 2, ..., len(a)-1]`</code>
 <code>Œ∫</code> |  | Length 1-Range | `one->len` | 1 | :x: | <code>a: any </code> => <code> `[1, 2, 3, ..., len(a)]`</code>
 <code>»ß</code> | #.a | Absolute Difference \| Apply to Neighbours | `abs-diff`, `apply-to-neighbours` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> |a - b|</code><br><code>a: lst, b: fun </code> => <code> apply b to each pair of neighbours in a [applies to windows of length 2]</code>
 <code>·∏É</code> |  | Bit \| Parity \| Last Half of String | `bit`, `parity`, `str-last-half` | 1 | :white_check_mark: | <code>a: num </code> => <code> parity of a (a % 2)</code><br><code>a: str </code> => <code> last half of a</code>
 <code>ƒã</code> | #.c | N Choose K (Binomial Coefficient) \| Character Set Equal? \| Repeat Until No Change | `n-choose-k`, `ncr`, `nck`, `choose`, `binomial`, `char-set-equal?`, `char-set-eq?`, `until-stable` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a choose b</code><br><code>a: str, b: str </code> => <code> are the character sets of a and b equal?</code><br><code>a: fun, b: any </code> => <code> run a on b until the result no longer changes returning all intermediate results</code>
 <code>·∏ã</code> | #.d | Dot Product \| To Bijective Base \| First Index Where Predicate Truthy | `dot-product`, `bijective-base`, `dot-prod`, `first-index-where`, `_*` | 2 | :x: | <code>a: lst, b: lst </code> => <code> Dot product of a and b</code><br><code>a: num, b: num </code> => <code> Convert a to bijective base b</code><br><code>a: lst, b: fun </code> => <code> First index of a where b is truthy</code>
 <code>ƒó</code> | #.e | Reciprocal \| Remove Whitespace | `reciprocal`, `recip`, `remove-whitespace`, `remove-space`, `1/` | 1 | :white_check_mark: | <code>a: num </code> => <code> 1/a</code><br><code>a: str </code> => <code> a with all whitespace removed</code>
 <code>·∏ü</code> | #.f | Prime Factors \| Remove Alphabet | `prime-factors`, `remove-alphabet` | 1 | :white_check_mark: | <code>a: num </code> => <code> prime factors of a</code><br><code>a: str </code> => <code> a with all alphabet characters removed</code>
 <code>ƒ°</code> | #.g | Group By Consecutive Items | `group-by-consecutive` | 1 | :x: | <code>a: any </code> => <code> group consecutive identical items of lst(a)</code>
 <code>·∏£</code> | #.h | Head Extract | `head-extract`, `split-at-head` | 1 | :x: | <code>a: lst|str </code> => <code> Push a[0], then a[1:] onto the stack</code>
 <code>≈Ä</code> | #.l | Transliterate \| Call While | `transliterate`, `call-while` | 3 | :x: | <code>any a, any b, any c </code> => <code> transliterate(a,b,c) (in a, replace b[0] with c[0], b[1] with c[1], b[2] with c[2], ...)</code><br><code>a: fun, b: fun, c: any </code> => <code> call b on c until a(c) is falsy</code>
 <code>·πÅ</code> | #.m | Mirror | `mirror`, `ab->abba` | 1 | :x: | <code>num a: a + reversed(a) (as number)</code><br><code>str a: a + reversed(a)</code><br><code>lst a: append reversed(a) to a</code>
 <code>·πÖ</code> | #.n | Palindromise | `palindromise`, `palindrome`, `ab->aba` | 1 | :x: | <code>a: any </code> => <code> palindromise a</code>
 <code>»Ø</code> | #.o | Boolify | `boolify` | 1 | :x: | <code>a: any </code> => <code> bool(a)</code>
 <code>·πó</code> | #.p | List Partitions \| Integer Partitions | `list-partitions`, `list-parts`, `integer-partitions`, `int-partitions`, `int-parts`, `partitions` | 1 | :x: | <code>a: lst </code> => <code> List partitions of a</code><br><code>a: num </code> => <code> Integer partitions of a (all possible ways to sum to a)</code>
 <code>·πô</code> | #.r | Rotate Right | `abc->cab`, `rot-right`, `rotate-right` | 1 | :x: | <code>a: any </code> => <code> rotate right once</code>
 <code>·π°</code> | #.s | Sort by Function Object \| Partition by Numbers \| Set Difference | `sort-by`, `sortby`, `sort-by-fun`, `sortbyfun`, `sort-fun`, `sortfun`, `partition-by`, `set-difference`, `set-diff` | 2 | :x: | <code>a: fun, b: any </code> => <code> sort iterable b by function a</code><br><code>a: any, b: fun </code> => <code> sort iterable a by function b</code><br><code>a: lst, b: lst </code> => <code> set difference of a and b</code><br><code>a: lst, b: num|str </code> => <code> remove b from a</code><br><code>a: num|str, b: lst </code> => <code> remove a from b</code>
 <code>·π´</code> | #.t | Last Extract \| Tail Extract | `last-extract`, `split-at-last`, `tail-extract` | 1 | :x: | <code>a: lst|str </code> => <code> Push a[:-1], a[-1] onto the stack</code>
 <code>·∫ã</code> | #.x | Cartesian Power \| Regex Search for Match | `cartesian-power`, `re-search`, `regex-search` | 2 | :x: | <code>a: lst, b: num </code> => <code> cart_prod([a] * n)</code><br><code>a: num, b: lst </code> => <code> cart_prod([b] * n)</code><br><code>a: str, b: str </code> => <code> return first index of pattern match b in target string a, -1 if not found</code><br><code>a: lst, b: str </code> => <code> regex search vectorised</code><br><code>a: str|lst, b: lst </code> => <code> push a, push cartesian product of b and b</code>
 <code>∆í</code> |  | Partition After Truthy Indices | `partition-after-truthy` | 2 | :x: | <code>a: lst, b: lst </code> => <code> partition a after truthy indices in b</code>
 <code>Œò</code> | #.` | Zero Slice Until | `0>b`, `zero-slice`, `zero-slice-until`, `take`, `slice-to`, `lst-truncate`, `first-n-items`, `first-n` | 2 | :x: | <code>a: lst, b: num>=0 </code> => <code> [a[0], a[1], ..., a[b-1]]</code><br><code>a: lst, b: num<0 </code> => <code> [a[b + 1], a[b + 2], ..., a[-1]]</code><br><code>a: lst, b: lst[num] </code> => <code> apl style take</code>
 <code>Œ¶</code> | #.\| | Slice from 1 | `1->b` | 2 | :x: | <code>a: lst, b: num </code> => <code> a[1:b]</code><br><code>a: num, b: lst </code> => <code> b[1:a]</code>
 <code>¬ß</code> | #,o | Print without newline | `print-no-newline` | NA | :x: | <code>a </code> => <code> printed to stdout without newline</code>
 <code>·∫†</code> | #,A | Assign | `assign`, `assign-at`, `assign<>`, `assign<x>`, `a<x>=`, `a<x>=y`, `a<x>?=y`, `set-item`, `apply-at`, `re-sub`, `regex-sub`, `@=>` | 3 | :x: | <code>a: lst, b: num, c: non-fun </code> => <code> assign c to a at the index b / a[b] = c</code><br><code>a: lst, b: num, c: fun </code> => <code> a[b] c= <stack items> (augmented assignment to list)</code><br><code>a: lst, b: lst, c: lst </code> => <code> assign c to a at the indices in b</code><br><code>a: str, b: str, c: str </code> => <code> replace regex matches of pattern b in string a with c</code><br><code>a: str, b: str, c: fun </code> => <code> replace regex matches of pattern b in string a with the result of applying c to each match</code><br><code>a: str, b: fun, c: str </code> => <code> replace regex matches of pattern c in string a with the result of applying b to each match</code><br><code>a: fun, b: str, c: str </code> => <code> replace regex matches of pattern c in string b with the result of applying a to each match</code><br><code>a: rec, b: str, c: str </code> => <code> a.b = c</code>
 <code>·∏Ñ</code> | #,B | Unique Prime Factors \| Case Of | `unique-prime-factors`, `case-of` | 1 | :white_check_mark: | <code>a: num </code> => <code> unique prime factors of a</code><br><code>a: str </code> => <code> case of each character of a (uppercase = 1, lowercase = 0)</code>
 <code>·∏§</code> | #,H | Head Extract Under | `head-extract-under`, `split-at-head-under`, `head-extract-swap`, `headless-swap`, `head-swap` | 1 | :x: | <code>a: lst|str </code> => <code> Push a[1:], then a[0] onto the stack</code>
 <code>·ªä</code> | #,I | Insert | `insert`, `insert-at` | 3 | :x: | <code>a: any, b: num, c: any </code> => <code> insert c at position b in a</code><br><code>a: any, b: lst, c: any </code> => <code> insert c at positions b in a</code><br><code>a: any, b: lst[num], c: lst </code> => <code> insert c[i] at position b[i] in a</code>
 <code>·∏∂</code> | #,L | Sort by Length \| Regex Escape | `sort-by-length`, `sort-by-len`, `order-by-length`, `order-by-len`, `length-sort`, `len-sort`, `re-escape`, `regex-escape` | 1 | :x: | <code>a: lst </code> => <code> sort a by length</code><br><code>a: str </code> => <code> escape a for regex</code>
 <code>·πÇ</code> | #,M | -1 Power Of \| Split on Spaces | `neg-one-power-of`, `neg1**`, `neg1^`, `neg1-power-of`, `neg1-power`, `split-on-spaces`, `split-spaces`, `space-split` | 1 | :white_check_mark: | <code>a: num </code> => <code> -1 ** a</code><br><code>a: str </code> => <code> a split on spaces</code>
 <code>·ªå</code> | #,O | Print without popping | `print-no-pop` | NA | :x: | <code>a </code> => <code> printed to stdout without popping</code>
 <code>·πö</code> | #,R | Reverse | `reverse`, `rev` | 1 | :x: | <code>a: any </code> => <code> reverse a</code>
 <code>·π¢</code> | #,S | Sublists | `sublists` | 1 | :x: | <code>a: lst </code> => <code> sublists of a</code>
 <code>·π¨</code> | #,T | Trim / Cumulative Reduce | `trim`, `scanl`, `cumulative-reduce` | 2 | :x: | <code>a: any, b: any </code> => <code> Trim all elements of b from both sides of a.</code><br><code>a: fun, b: any </code> => <code> cumulative reduce b by function a</code>
 <code>‚Ä¶</code> | #.. | Increment Twice \| Vectorised Head | `incr-twice`, `vec-head` | 1 | :x: | <code>a: num </code> => <code> a + 2</code><br><code>a: lst </code> => <code> [x[0] for x in a]</code>
 <code>‚â§</code> | #,< | Less Than Or Equal To | `le`, `less-than-or-equal-to` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a <= b</code><br><code>a: str, b: num </code> => <code> a <= str(b)</code><br><code>a: num, b: str </code> => <code> str(a) <= b</code><br><code>a: str, b: str </code> => <code> a <= b</code>
 <code>‚â•</code> | #,> | Greater Than Or Equal To | `ge`, `greater-than-or-equal-to` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a >= b</code><br><code>a: str, b: num </code> => <code> a >= str(b)</code><br><code>a: num, b: str </code> => <code> str(a) >= b</code><br><code>a: str, b: str </code> => <code> a >= b</code>
 <code>‚â†</code> | #.= | Not Equal | `not-equal`, `=n't` | 2 | :white_check_mark: | <code>a: any, b: any </code> => <code> a != b</code>
 <code>‚Çå</code> | #,= | Exactly Equals | `===`, `exactly-equal`, `strictly-equal?` | 2 | :x: | <code>a: any, b: any </code> => <code> a === b (non-vectorising)</code>
 <code>‚Å∫</code> | #^+ | Powerset | `powerset` | 1 | :x: | <code>a: lst </code> => <code> powerset of a</code>
 <code>‚Åª</code> | #^- | Cube \| Threes | `cube`, `threes` | 1 | :white_check_mark: | <code>a: num </code> => <code> a ** 3</code><br><code>a: str </code> => <code> a split into chunks of length 3</code>
 <code>‚Åæ</code> | #^) | Set Intersection \| Flatten By Depth \| Character Multiply | `set-intersection`, `intersection`, `flatten-by-depth`, `intersect` | 2 | :x: | <code>a: lst, b: lst </code> => <code> set intersection of a and b</code><br><code>a: str, b: str </code> => <code> set intersection of a and b</code><br><code>a: lst, b: num </code> => <code> flatten a by depth b</code><br><code>a: num, b: str </code> => <code> each character in b repeated a times</code><br><code>a: str, b: num </code> => <code> each character in a repeated b times</code>
 <code>‚àö</code> | #,* | Square Root | `sqrt`, `square-root` | 1 | :white_check_mark: | <code>a: num </code> => <code> sqrt(a)</code>
 <code>‚àë</code> |  | Sum | `sum`, `/+`, `+/` | 1 | :x: | <code>a: lst </code> => <code> sum of a</code>
 <code>¬´</code> | #.< | Bitshift Left | `bitwise-left-shift`, `left-shift`, `left-pad`, `pad-left` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a << b</code><br><code>a: num, b: str </code> => <code> b padded to length a with spaces prepended</code><br><code>a: str, b: num </code> => <code> a padded to length b with spaces prepended</code><br><code>a: str, b: str </code> => <code> a padded to length of b with spaces prepended</code>
 <code>¬ª</code> | #.> | Bitshift Right | `bitwise-right-shift`, `right-shift`, `right-pad`, `pad-right` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a >> b</code><br><code>a: num, b: str </code> => <code> b padded to length a with spaces appended</code><br><code>a: str, b: num </code> => <code> a padded to length b with spaces appended</code><br><code>a: str, b: str </code> => <code> a padded to length of b with spaces appended</code>
 <code>‚åê</code> | #.! | Bitwise Not | `bitwise-not` | 1 | :white_check_mark: | <code>a: num </code> => <code> ~a</code>
 <code>‚à¥</code> | #.: | Bitwise And | `bitwise-and` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a & b</code>
 <code>‚àµ</code> | #,: | Bitwise Or | `bitwise-or` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a | b</code>
 <code>‚äª</code> | #,v | Bitwise Xor | `bitwise-xor`, `insert-space` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a ^ b</code><br><code>a: str, b: str </code> => <code> a + space + b</code>
 <code>‚ÇÄ</code> | #,0 | Ten | `ten`, `l0` | 0 | :x: | <code></code> => <code> 10</code>
 <code>‚ÇÅ</code> | #,1 | Sixteen | `sixteen`, `l6` | 0 | :x: | <code></code> => <code> 16</code>
 <code>‚ÇÇ</code> | #,2 | Twenty-six | `twenty-six`, `Z6`, `z6` | 0 | :x: | <code></code> => <code> 26</code>
 <code>‚ÇÉ</code> | #,3 | Thirty-two | `thirty-two`, `E2` | 0 | :x: | <code></code> => <code> 32</code>
 <code>‚ÇÑ</code> | #,4 | Sixty-four | `sixty-four`, `b4` | 0 | :x: | <code></code> => <code> 64</code>
 <code>‚ÇÖ</code> | #,5 | One hundred | `one-hundred`, `l00` | 0 | :x: | <code></code> => <code> 100</code>
 <code>‚ÇÜ</code> | #,6 | One hundred twenty-eight | `one-hundred-twenty-eight`, `l28` | 0 | :x: | <code></code> => <code> 128</code>
 <code>‚Çá</code> | #,7 | Two hundred fifty-six | `two-hundred-fifty-six`, `Z56`, `z56` | 0 | :x: | <code></code> => <code> 256</code>
 <code>‚Çà</code> | #,8 | -1 | `negative-one`, `neg-1`, `-1` | 0 | :x: | <code></code> => <code> -1</code>
 <code>‚Çâ</code> | #,9 | Empty string | `empty-string`, `<>` | 0 | :x: | <code></code> => <code> ""</code>
 <code>¬Ω</code> | #.5 | Halve | `halve` | 1 | :white_check_mark: | <code>a: num </code> => <code> a / 2</code><br><code>a: str </code> => <code> a split into two pieces</code>
 <code> Ä</code> | #.~ | Exclusive Zero Range \| Lowercase | `0->n`, `zero-range`, `lowered-range`, `to-lower`, `lower`, `lowercase` | 1 | :white_check_mark: | <code>a: num </code> => <code> [0..a)</code><br><code>a: lst[num] </code> => <code> apl-style iota from 0 until a</code><br><code>a: str </code> => <code> a.lower()</code>
 <code>…æ</code> | #,~ | Inclusive One Range \| Uppercase | `one->n`, `one-range`, `to-upper`, `upper`, `uppercase` | 1 | :white_check_mark: | <code>a: num </code> => <code> [1..a]</code><br><code>a: lst[num] </code> => <code> apl-style iota from 1 to a</code><br><code>a: str </code> => <code> a.upper()</code>
 <code>¬Ø</code> | #^_ | Deltas | `deltas` | 1 | :x: | <code>a: lst </code> => <code> forward-differences of a</code>
 <code>√ó</code> | #.* | Multiplication | `mul`, `multiply`, `times`, `str-repeat`, `*`, `ring-trans` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a * b</code><br><code>a: num, b: str </code> => <code> b repeated a times</code><br><code>a: str, b: num </code> => <code> a repeated b times</code><br><code>a: str, b: str </code> => <code> ring translate a according to b</code>
 <code>√∑</code> | #./ | Divide \| Split | `divide`, `div`, `str-split`, `re-split`, `str-n-pieces`, `n-strings`, `str-pieces`, `string-pieces` | 2 | :white_check_mark: | <code>a: num, b: num </code> => <code> a / b</code><br><code>a: str, b: num </code> => <code> a split into b equal sized chunks, with the last chunk potentially smaller</code><br><code>a: num, b: str </code> => <code> b split into a equal sized chunks, with the last chunk potentially smaller</code><br><code>a: str, b: str </code> => <code> Split a on the regex b</code>
 <code>¬£</code> | #^= | Set Register | `set-register`, `->register`, `set-reg`, `->reg` | 1 | :x: | <code>a: any </code> => <code> register = a</code>
 <code>¬•</code> | #^$ | Get Register | `get-register`, `get-reg`, `register`, `<-register`, `<-reg` | NA | :x: | <code> </code> => <code> push the value of the register</code>
 <code>‚Üê</code> | #^< | Rotate Stack Left | `rotate-stack-left` | NA | :x: | <code> </code> => <code> rotate the entire stack left once</code>
 <code>‚Üë</code> | #^^ | Grade Up | `grade-up` | 1 | :x: | <code>a: any </code> => <code> indices that will sort a</code>
 <code>‚Üí</code> | #^> | Rotate Stack Right | `rotate-stack-right` | NA | :x: | <code> </code> => <code> rotate the entire stack right once</code>
 <code>‚Üì</code> | #^; | Grade Down | `grade-down` | 1 | :x: | <code>a: any </code> => <code> indices that will reverse-sort a</code>
 <code>¬±</code> | #,+ | Sign | `sign` | 1 | :white_check_mark: | <code>a: num </code> => <code> sign of a</code>
 <code>‚Ä†</code> | #.& | Length of Consecutive Groups | `len-consecutive`, `gvl`, `gavel` | 1 | :x: | <code>a: any </code> => <code> lengths of consecutive groups of a</code>
 <code>Œ†</code> |  | Product | `product`, `prod` | 1 | :x: | <code>a: lst </code> => <code> product of a</code>
 <code>¬¨</code> | #,! | Logical Not | `non-vec-not`, `non-vec-logical-not` | 1 | :x: | <code>a: any </code> => <code> !a</code>
 <code>‚àß</code> | #,& | Logical And | `and`, `logical-and` | 2 | :white_check_mark: | <code>a: any, b: any </code> => <code> a && b</code>
 <code>‚à®</code> | #,\| | Logical Or | `or`, `logical-or` | 2 | :white_check_mark: | <code>a: any, b: any </code> => <code> a || b</code>
 <code>‚Å∞</code> | #^0 | First Input | `first-input`, `input-0` | 0 | :x: | <code>The first input to the program</code>
 <code>¬π</code> | #^1 | Second Input | `second-input`, `input-1` | 0 | :x: | <code>The second input to the program</code>
 <code>¬≤</code> | #^2 | Square \| Pairs | `square`, `pairs` | 1 | :white_check_mark: | <code>a: num </code> => <code> a ** 2</code><br><code>a: str </code> => <code> a split into pairs</code>
 <code>‚åà</code> |  | Ceiling | `ceiling`, `ceil` | 1 | :white_check_mark: | <code>a: num </code> => <code> ceil(a)</code>
 <code>‚åä</code> |  | Floor | `floor`, `str-num`, `str->num`, `str-to-num` | 1 | :white_check_mark: | <code>a: num </code> => <code> floor(a)</code><br><code>a: str </code> => <code> cast a to num by ignoring non-numeric digits. Returns 0 if there's no valid number</code>
 <code>∆ì</code> | #.9 | Maximum without popping | `max-no-pop` | 1 | :x: | <code>a: lst </code> => <code> max(a) without popping a</code>
 <code>…†</code> | #.6 | Minimum without popping | `min-no-pop` | 1 | :x: | <code>a: lst </code> => <code> min(a) without popping a</code>
 <code>‚Äû</code> | #," | Join on Spaces \| Is Negative? (Used when not closing a string) | `space-join`, `join-on-spaces`, `is-negative?`, `negative?` | 1 | :x: | <code>a: lst </code> => <code> a join on spaces</code><br><code>a: num </code> => <code> a < 0</code>
 <code>‚Äù</code> | #^' | Join On Newlines \| Pad Binary to Mod 8 \| Context if 1 | `join-newlines`, `newline-join`, `join-on-newlines`, `binary-pad-8`, `bin-pad-8`, `one?->context`, `one?->n` | 1 | :x: | <code>a: lst </code> => <code> a join on newlines</code><br><code>a: str </code> => <code> a padded to a multiple of 8 with 0s</code><br><code>a: num </code> => <code> a if a == 1 push context variable n</code>
 <code>√∞</code> | #.b | Space | `space` | 0 | :x: | <code></code> => <code> " "</code>
 <code>‚Ç¨</code> | #^( | Suffixes | `suffixes` | 1 | :x: | <code>a: lst </code> => <code> Suffixes of a</code>
 <code>‚Äú</code> | #^" | Join on Nothing \| First Positive Integer \| Is Alphanumeric \| Insignificant? | `nothing-join`, `concat-fold`, `join-on-nothing`, `empty-join`, `single-string`, `as-single-string`, `first-positive-integer`, `first-n>0`, `is-alphanumeric`, `is-alphanum`, `is-alnum`, `abs<=1`, `insignificant?`, `insignificant`, `insig?`, `insig` | 1 | :x: | <code>a: lst </code> => <code> a join on nothing</code><br><code>a: str </code> => <code> is a alphanumeric?</code><br><code>a: fun </code> => <code> First positive integer ([1, 2, 3, ...]) for which a returns true</code><br><code>a: num </code> => <code> abs(a) <= 1</code>
 <code>¬∂</code> | #,‚ê§ | Newline | `newline` | 0 | :x: | <code></code> => <code> chr(10)</code>
 <code>·∂ø</code> | #^` | Bifuricate | `bifuricate`, `bifur`, `bif`, `furry`, `uwu`, `dup-rev`, `dup-reverse`, `owo` | 1 | :x: | <code>a: lst </code> => <code> Push a, then push a reversed</code>
 <code>·∂≤</code> | #^\| | Stringify | `to-string`, `stringify`, `str` | 1 | :x: | <code>a: any </code> => <code> str(a)</code>
 <code>‚Ä¢</code> | #,. | Asterisk | `asterisk` | 0 | :x: | <code></code> => <code> "*"</code>
 <code>‚âà</code> | #^~ | All Equal? | `all-equal`, `all-equal?` | 1 | :x: | <code>a: lst </code> => <code> are all elements of a equal?</code>
 <code>Íúù</code> | #^! | Increment | `incr`, `increment` | 1 | :white_check_mark: | <code>a: num </code> => <code> a + 1</code>
 <code>#?</code> |  | All Inputs | `all-inputs`, `inputs`, `all-stdin`, `all-stdin?` | NA | :x: | <code>A list of all inputs to the program</code>
 <code>#C</code> |  | Compress String Using Dictionary | `compress-dict`, `dict-comp`, `compress` | 1 | :x: | <code>a: str </code> => <code> compress a using the dictionary</code>
 <code>#Q</code> |  | Exit \| Quit | `exit`, `quit` | NA | :x: | <code>a </code> => <code> Stop program execution</code>
 <code>#X</code> |  | Loop Break | `break` | 0 | :x: | <code> </code> => <code> break out of the current loop</code>
 <code>#c</code> |  | Base-252 Compress String or Number | `compress-252`, `compress-b` | 1 | :white_check_mark: | <code>a: str </code> => <code> compress a using base 252</code><br><code>a: num </code> => <code> compress a using base 252</code>
 <code>#v</code> |  | [Internal Use] Vectorise (Element Form) |  | NA | :x: | <code>*a, f </code> => <code> f vectorised over however many arguments in a. It is recommended to use the modifier instead</code>
 <code>#x</code> |  | Loop Continue | `continue` | 0 | :x: | <code> </code> => <code> continue the current loop</code>
 <code>#~</code> |  | [Internal Use] Apply Without Popping (Element Form) |  | NA | :x: | <code>*a, f </code> => <code> f applied to the stack without popping items. Use the modifier instead.</code>
 <code>#¬§</code> |  | Number of Context Parameters | `number-of-context`, `context-number`, `context-count` | 0 | :x: | <code></code> => <code> number of context parameters</code>
 <code>#¬ø</code> |  | Number of Inputs | `number-of-inputs`, `count-inputs`, `count-stdin` | 0 | :x: | <code></code> => <code> The number of inputs to the program</code>
 <code>‚àÜ<</code> |  | Argument / Phase / Angle | `arg`, `phase`, `angle` | 1 | :white_check_mark: | <code>a: num </code> => <code> Arg(a)</code>
 <code>‚àÜC</code> |  | Hyperbolic Cosine | `cosh`, `hyperbolic-cosine` | 1 | :white_check_mark: | <code>a: num </code> => <code> cosh(a)</code>
 <code>‚àÜI</code> |  | Imaginary Part | `imag`, `imaginary`, `imaginary-part` | 1 | :white_check_mark: | <code>a: num </code> => <code> Im(a)</code>
 <code>‚àÜL</code> |  | Least Common Multiple | `lcm` | 2 | :x: | <code>a: num, b: num </code> => <code> lcm(a, b)</code><br><code>a: lst[num], b: num </code> => <code> lcm of b and all elements of a</code><br><code>a: lst[num] </code> => <code> lcm of all items in a.</code>
 <code>‚àÜR</code> |  | Real Part | `real`, `real-part` | 1 | :white_check_mark: | <code>a: num </code> => <code> Re(a)</code>
 <code>‚àÜS</code> |  | Hyperbolic Sine | `sinh`, `hyperbolic-sine` | 1 | :white_check_mark: | <code>a: num </code> => <code> sinh(a)</code>
 <code>‚àÜT</code> |  | Hyperbolic Tangent | `tanh`, `hyperbolic-tangent` | 1 | :white_check_mark: | <code>a: num </code> => <code> tanh(a)</code>
 <code>‚àÜc</code> |  | Cosine | `cos`, `cosine` | 1 | :white_check_mark: | <code>a: num </code> => <code> cos(a)</code>
 <code>‚àÜq</code> |  | Prime Exponents | `prime-exponents`, `prime-exps` | 1 | :white_check_mark: | <code>a: num </code> => <code> push a list of the power of each prime in the prime factors of a</code>
 <code>‚àÜs</code> |  | Sine | `sin`, `sine` | 1 | :white_check_mark: | <code>a: num </code> => <code> sin(a)</code>
 <code>‚àÜt</code> |  | Tangent | `tan`, `tangent` | 1 | :white_check_mark: | <code>a: num </code> => <code> tan(a)</code>
 <code>‚àÜ·π™</code> |  | Dyadic Arctangent / Dyadic Inverse Tangent | `atan2`, `arctan2`, `arctangent2` | 2 | :white_check_mark: | <code>y: num, x: num </code> => <code> atan2(y, x)</code>
 <code>‚àÜƒã</code> |  | Arccosine / Inverse Cosine | `acos`, `arccos`, `arccosine` | 1 | :white_check_mark: | <code>a: num </code> => <code> acos(a)</code>
 <code>‚àÜ·∏ã</code> |  | Radians to Degrees | `rad2deg`, `rad-to-deg` | 1 | :white_check_mark: | <code>a: num </code> => <code> a from radians to degrees (a * 180 / pi)</code>
 <code>‚àÜ·∏ü</code> |  | All Prime Exponents | `all-prime-exponents`, `all-prime-exps` | 1 | :white_check_mark: | <code>a: num </code> => <code> for all primes less than or equal to a, push the power of that prime in the factorisation of a</code>
 <code>‚àÜ·πô</code> |  | Degrees to Radians | `deg2rad`, `deg-to-rad` | 1 | :white_check_mark: | <code>a: num </code> => <code> a from degrees to radians (a * pi / 180)</code>
 <code>‚àÜ·π°</code> |  | Arcsine / Inverse Sine | `asin`, `arcsin`, `arcsine` | 1 | :white_check_mark: | <code>a: num </code> => <code> asin(a)</code>
 <code>‚àÜ·π´</code> |  | Arctangent / Inverse Tangent | `atan`, `arctan`, `arctangent` | 1 | :white_check_mark: | <code>a: num </code> => <code> atan(a)</code>
 <code>√∏‚Åæ</code> |  | Surround | `surround` | 2 | :x: | <code>a: any, b: any </code> => <code> a prepended and appended to b</code>
 <code>√û0</code> |  | Zero Pad | `zero-pad`, `pizza-tower` | 2 | :x: | <code>a: lst|str, b: num </code> => <code> a padded with 0s to length b. Positive b prepends 0s, negative b appends 0s</code><br><code>a: lst|str, b: lst|str </code> => <code> a padded with 0s to length of b. Positive b prepends 0s, negative b appends 0s</code>
 <code>√ûO</code> |  | Grid Neighbours (Wrap Around) | `grid-neighbours-wrap`, `grid-neighbors-wrap`, `adjacent-cells-wrap`, `adj-cells-wrap`, `surrounding-cells-wrap` | 1 | :x: | <code>a: lst[lst] </code> => <code> Grid neighbours of a - up, down, left, right - wrapping around</code><br><code>a: lst[lst], b: num </code> => <code> Grid neighbours of a - right, down, left, up of a, wrapping around and start from direction b => 0: right, 1: down, 2: left, 3: up. Negative b does not include middle, positive b does</code>
 <code>√ûP</code> |  | Set of All Primes | `PP`, `primes` | 0 | :x: | <code></code> => <code> The set of all primes</code>
 <code>√ûR</code> |  | Reshape | `reshape` | 2 | :x: | <code>a: lst, b: lst[num] => a reshaped to shape b</code>
 <code>√ûT</code> |  | Transpose Safe | `transpose-safe` | 1 | :x: | <code>a: any </code> => <code> transpose a</code>
 <code>√ûh</code> |  | Ends | `ends`, `sides`, `edges` | 1 | :x: | <code>a: lst </code> => <code> [a[0], a[-1]]</code><br><code>a: str </code> => <code> [a[0], a[-1]]</code>
 <code>√ûi</code> |  | Multidimensional Index | `md-index` | 2 | :x: | <code>a: lst, b: lst[num] </code> => <code> a[b[0]][b[1]]...[b[n]]</code>
 <code>√ûo</code> |  | Grid Neighbours | `grid-neighbours`, `grid-neighbors`, `adjacent-cells`, `adj-cells`, `surrounding-cells` | 1 | :x: | <code>a: lst[lst] </code> => <code> Grid neighbours of a - right, down, left, up of a</code><br><code>a: lst[lst], b: num </code> => <code> Grid neighbours of a - right, down, left, up of a and start from direction b => 0: right, 1: down, 2: left, 3: up. Negative b does not include middle, positive b does</code>
 <code>√ûƒä</code> |  | Cycle \| Is Positive? | `cycle`, `is-positive?`, `positive?`, `>0?` | 1 | :x: | <code>a: lst </code> => <code> a ++ a ++ a ++ ...</code><br><code>a: num </code> => <code> a > 0</code>
 <code>√û»Æ</code> |  | Grid Neighbours (Diagonals, Wrap Around) | `grid-neighbours-diagonals-wrap`, `grid-neighbors-diagonals-wrap`, `adjacent-cells-diagonals-wrap`, `adj-cells-diagonals-wrap`, `surrounding-cells-diagonals-wrap`, `eight-cells-wrap` | 1 | :x: | <code>a: lst[lst] </code> => <code> Grid neighbours of a - up, down, left, right, diagonals - wrapping around</code><br><code>a: lst[lst], b: num </code> => <code> Grid neighbours of a - right, down, left, up of a, wrapping around and start from direction b => 0: right, 1: down, 2: left, 3: up, 4: down-right, 5: up-left, 6: down-left, 7: up-left. Negative b does not include middle, positive b does</code>
 <code>√û·∫ä</code> |  | Cartesian Product Unsafe | `cartesian-product-unsafe`, `cartesian-unsafe`, `cart-prod-unsafe`, `cart-unsafe` | 2 | :x: | <code>a: list, b: list </code> => <code> cartesian product of a and b in the standard order, but without accounting for infinite lists</code>
 <code>√ûŒπ</code> |  | 0-Lift | `zero-lift`, `lift-0`, `O-lift` | 1 | :x: | <code>a: lst </code> => <code> each item of a multiplied by its 0-based index</code>
 <code>√ûŒ∫</code> |  | 1-Lift | `one-lift`, `lift-1`, `l-lift` | 1 | :x: | <code>a: lst </code> => <code> each item of a multiplied by its 1-based index</code>
 <code>√ûƒã</code> |  | Multi-Set XOR | `multi-set-xor` | 2 | :x: | <code>a: lst, b: lst </code> => <code> multi-set xor of a and b</code>
 <code>√û·πÖ</code> |  | Multi-Set Difference | `multi-set-difference`, `multi-set-diff` | 2 | :x: | <code>a: lst, b: lst </code> => <code> multi-set difference of a and b</code>
 <code>√û»Ø</code> |  | Grid Neighbours (Diagonals) | `grid-neighbours-diagonals`, `grid-neighbors-diagonals`, `adjacent-cells-diagonals`, `adj-cells-diagonals`, `surrounding-cells-diagonals`, `eight-cells` | 1 | :x: | <code>a: lst[lst] </code> => <code> Grid neighbours of a - up, down, left, right, diagonals</code><br><code>a: lst[lst], b: num </code> => <code> Grid neighbours of a - right, down, left, up of a and start from direction b => 0: right, 1: down, 2: left, 3: up, 4: down-right, 5: up-left, 6: down-left, 7: up-left. Negative b does not include middle, positive b does</code>
 <code>√û·∫†</code> |  | Multidimensional Assignment | `md-assign` | 3 | :x: | <code>a: lst, b: lst[num], c: any </code> => <code> a[b[0]][b[1]]...[b[n]] = c</code>
 <code>√û·πÇ</code> |  | Matrix Inverse | `matrix-inverse` | 1 | :white_check_mark: | <code>a: lst[lst] </code> => <code> matrix inverse of a</code>
 <code>√û·πÜ</code> |  | Set of Natural Numbers | `NN` | 0 | :x: | <code></code> => <code> The set of all natural numbers</code>
 <code>√û·π¨</code> |  | Set of Integers | `ZZ` | 0 | :x: | <code></code> => <code> The set of all integers</code>
 <code>√û‚Åæ</code> |  | Multi-Set Intersection | `multi-set-intersection`, `multi-set-intersect` | 2 | :x: | <code>a: lst, b: lst </code> => <code> multi-set intersection of a and b</code>
 <code>√û√∑</code> |  | Into N Pieces \| Split Into N Pieces | `into-n-pieces`, `split-into-n-pieces` | 2 | :x: | <code>a: lst, b: num </code> => <code> a split into b equal sized chunks, with the last chunk potentially smaller</code><br><code>a: str, b: num </code> => <code> a split into b equal sized chunks, with the last chunk potentially smaller</code>

## Modifiers

| Symbol | Trigraph | Name | Keywords | Arity | Description | Usage |
 --- | --- | --- | --- | --- | --- | --- |
 <code>·µÉ</code> | <code>#^a</code> | Apply to Neighbours \| Number of Truthy Elements | `apply-to-neighbours:`, `count-truthy:`, `apply-neighbours:`, `apply-to-neighbors:`, `apply-neighbors:`, `2lvf:`, `twolif:`, `to-pairs:`, `to-overlaps:`, `count:` | 1 | To each overlapping pair, reduce it by an element<br>Apply a dyadic element for all pairs of neighboring elements.<br>Count the number of truthy elements in a list under a mondaic element | <code>»ßf<monad>: Count how many items in a list are truthy after applying f to each</code><br><code>·µÉf<dyad>: equivalent to pushing the function, then calling »ß</code>
 <code>·µá</code> | <code>#^b</code> | Apply Without Popping \| Remove Duplicates by | `without-popping:`, `peek:`, `dedup-by:`, `remove-duplicates-by:` | 1 | Apply a 2+ arity element to the stack without popping<br>Remove duplicates from a list by an element | <code>·µáf<dyad|triad|tetrad>: apply f to the stack without popping</code><br><code>·µáf<monad>: remove duplicates from a list by applying f to each pair of elements</code>
 <code>·∂ú</code> | <code>#^c</code> | Reduce Columns \| Map Over Suffixes | `reduce-columns:`, `map-over-suffixes:`, `fold-cols:`, `foldl-cols:`, `fold-columns-by:`, `reduce-columns-by:`, `over-suffixes:` | 1 | Reduce columns of a 2d list by a function<br>Map an element over suffixes | 
 <code>·µà</code> | <code>#^d</code> | Dyadic Single Element Lambda | `*2:` | 1 | Turn the next element (whether that be a structure/modifier/element) into a dyadic lambda | <code>·µàf: Push the equivalent of Œª2|f} to the stack</code>
 <code>·µâ</code> | <code>#^e</code> | Dyadic Double Element Lambda | `**2:` | 2 | Turn the next two elements (whether that be a structure/modifier/element) into a dyadic lambda | <code>·µâfg: Push the equivalent of Œª2|fg} to the stack</code>
 <code>·∂†</code> | <code>#^f</code> | Dyadic Triple Element Lambda | `***2:` | 3 | Turn the next three elements (whether that be a structure/modifier/element) into a dyadic lambda | <code>·∂†fgh: Push the equivalent of Œª2|fgh} to the stack</code>
 <code>·¥≥</code> | <code></code> | Dyadic Quadruple Element Lambda | `****2:` | 4 | Turn the next four elements (whether that be a structure/modifier/element) into a dyadic lambda | <code>·µçfghi: Push the equivalent of Œª2|fghi} to the stack</code>
 <code>·¥¥</code> | <code>#^H</code> | Apply To Head | `apply-to-head:` | 1 | Apply element only to the head of list | <code>·¥¥f: Apply f to the head of the top of the stack</code>
 <code>·∂§</code> | <code>#^i</code> | First Index Where | `first-index-where:`, `first-index-of:`, `ind-of:`, `find-by:` | 1 | Find the first index where an element is truthy | <code>·∂§f: find the first index where f is truthy</code>
 <code>·∂®</code> | <code>#^j</code> | Loop and Collect While Unique | `collect-while-unique:` | 1 | Loop and Collect While Unique | <code>·∂®f: Loop and collect while unique</code>
 <code>·µè</code> | <code>#^k</code> | Key | `key:` | 1 | Map an element over the groups formed by identical items. | <code>·µèf: Map f over the groups formed by identical items</code>
 <code>·∂™</code> | <code>#^l</code> | Loop While Unique | `loop-while-unique:` | 1 | Loop While Unique - similar to ·∂®, but doesn't collect | <code>·∂™f: Loop while unique</code>
 <code>·µê</code> | <code>#^m</code> | Maximum By | `max-by:`, `maximum-by:` | 1 | Maximum By Element | <code>·µêf: Maximum of top of stack based on results of f</code>
 <code>‚Åø</code> | <code>#^n</code> | Minimum By | `min-by:`, `minimum-by:` | 1 | Minimum By Element | <code>·µêf: Minimum of top of stack based on results of f</code>
 <code>·µí</code> | <code>#^o</code> | Outer Product \| Table | `outer-product:`, `table:` | 1 | Outer product | <code>·µíf: Pop two lists, then make a matrix from them by applying f to each pair of elements</code>
 <code>·µñ</code> | <code>#^p</code> | Map Over Prefixes | `map-over-prefixes:`, `over-prefixes:` | 1 | Map an element over the prefixes of a list | <code>·µñf: Map f over prefixes</code>
 <code>·¥ø</code> | <code>#^R</code> | Apply to Register | `apply-to-register:`, `to-register:`, `to-reg:` | 1 | Apply a function to the register. Essentially, push<br>the register value to the stack, apply the function, and<br>then pop back into the register | <code>·¥øf: Apply f to the register</code>
 <code>·∂≥</code> | <code>#^s</code> | Sort By | `sort-by:`, `scanl:` | 1 | Sort By Element / Scanl | <code>·∂≥f: Sort top of stack based on results of f</code><br><code>·∂≥f: Cumulatively reduce a list of items</code>
 <code>·µó</code> | <code>#^t</code> | Map as Stacks | `vec-dump:`, `map-dump:` | 1 | Map a function over the top of the stack, treating each iteration<br>as if it were a stack of items. Essentially, dump before mapping | 
 <code>·µò</code> | <code>#^u</code> | Collect Until No Change / Neighbours All Equal? | `collect-until-no-change:`, `until-stable:`, `stablise:`, `neighbours-equals:` | 1 | Run func on the prev result until the result no longer changes<br>returning all intermediate results<br>Given a dyadic function, apply the function to all overlapping pairs of elements<br>and test if all results are equal | <code>·µòf: Collect until no change</code>
 <code>·µõ</code> | <code>#^v</code> | Vectorise | `vectorise:`, `vec:`, `v:` | 1 | Vectorises | <code>·µõf: f but vectorised</code>
 <code>·µÇ</code> | <code>#^W</code> | Dip | `dip:` | 1 | Stash the top of the stack temporarily, and then apply<br>the function. Finally, push the stashed value | <code>·µÇf: pop M, apply f, push M</code>
 <code>·µ°</code> | <code>#^X</code> | Scan Fixed Point | `scan-fix:` | 1 | Scan a function until it reaches a fixed point | <code>·µ°f: scan f until a fixed point is reached / apply until a previous value is repeated, collecting intermediate results</code>
 <code>·µû</code> | <code>#^y</code> | Invariant Under? / Vertical Scan | `invariant-under:`, `vertical-scan:`, `vscan:`, `v-scan:`, `invariant?:`, `same?:` | 1 | Check if a function is invariant under a transformation / vertical scan | <code>·µûf: check if top of stack is invariant under a transformation</code><br><code>·µûf: scanl columns by f</code>
 <code>·∂ª</code> | <code>#^z</code> | Zip With / Reject by | `zip-with:`, `zipwith:` | 1 | Given a dyadic function, zip two lists and reduce each by f<br> and then check if all results are equal.<br>Given a monadic function, the inverse of monadic /.<br>Filters where the function is falsey | 
 <code>‚∏†</code> | <code>#^.</code> | Single Element Lambda | `*:` | 1 | Turn the next element (whether that be a structure/modifier/element) into a lambda | <code>‚∏†f: Push the equivalent of Œªf} to the stack</code>
 <code>œ©</code> | <code>#^:</code> | Double Element Lambda | `**:` | 2 | Turn the next two elements (whether that be a structure/modifier/element) into a lambda | <code>œ©fg: Push the equivalent of Œªfg} to the stack</code>
 <code>—ç</code> | <code>#^%</code> | Triple Element Lambda | `***:` | 3 | Turn the next three elements (whether that be a structure/modifier/element) into a lambda | <code>—çfgh: Push the equivalent of Œªfgh} to the stack</code>
 <code>–ß</code> | <code>#^4</code> | Quadruple Element Lambda | `****:` | 4 | Turn the next four elements (whether that be a structure/modifier/element) into a lambda | <code>–ßfghi: Push the equivalent of Œªfghi} to the stack</code>
 <code>·µú</code> | <code>#^*</code> | Lambda to Newline | `<-}` | -1 | Scan elements to the left until a newline is found. Push a<br>lambda with all of the scanned elements | <code><elements>·µú: Push a lambda</code>
 <code>/</code> | <code></code> | Foldl \| Reduce By \| Filter by | `foldl:`, `reduce:`, `/:`, `fold:`, `reduceby:-` | 1 | Reduce a list by an element | <code>/f: reduce by element f</code>
 <code>‚à•</code> | <code></code> | Parallel Apply | `parallel-apply:`, `para-apply:`, `paraply:`, `!!:` | 2 | Parallel apply two elements to the top of the stack | 
 <code>‚à¶</code> | <code></code> | Parallel Apply and Wrap | `parallel-apply-and-wrap:`, `para-apply-and-wrap:`, `<paraply>:`, `<!!>:` | 2 | Parallel apply two elements to the top of the stack<br>and wrap the result in a list | 
 <code>¬ø</code> | <code>#.?</code> | Conditional Execution | `if-top:`, `if:` | 1 | Pop the top of the stack, and, if it's truthy, apply a function | 

## Syntax Features

| Symbol | Trigraph | Name | Keywords (if applicable) | Description | Usage |
 --- | --- | --- | --- | --- | --- |
 `·∂¥` |  | Two Character String | <code></code> | Push the next two characters as a string | <pre>·∂¥&lt;character&gt;&lt;character&gt;</pre>
 `"` |  | Open/Close String | <code></code> | Open/close a string. If the string is closed, push it to the stack. Closes all string types | <pre>"string contents"</pre>
 `'` |  | One Character String | <code></code> | Push the next character as a string | <pre>'&lt;character&gt;</pre>
 `(` |  | For Loop | <code>for for< do-to-each each-as</code> | Open a for loop. For each item in the top of the stack, execute code, storing loop variable. | <pre>&lt;iterable&gt; (&lt;variable&gt;\|&lt;code&gt;}</pre>
 `)` |  | Close Two Structures | <code>end-end</code> | Match and close two open structures. | <pre>&lt;structure open&gt;&lt;structure open&gt; &lt;code&gt; ) &lt;code not in structure&gt;</pre>
 `.` |  | Decimal Separator | <code></code> | Used to separate the integer and fractional parts of a number | <pre>&lt;integer&gt;.&lt;fractional&gt;</pre>
 `0` |  | Numeric Literal | <code></code> | The number 0 | <pre>0</pre>
 `1` |  | Numeric Literal | <code></code> | The number 1 | <pre>1</pre>
 `2` |  | Numeric Literal | <code></code> | The number 2 | <pre>2</pre>
 `3` |  | Numeric Literal | <code></code> | The number 3 | <pre>3</pre>
 `4` |  | Numeric Literal | <code></code> | The number 4 | <pre>4</pre>
 `5` |  | Numeric Literal | <code></code> | The number 5 | <pre>5</pre>
 `6` |  | Numeric Literal | <code></code> | The number 6 | <pre>6</pre>
 `7` |  | Numeric Literal | <code></code> | The number 7 | <pre>7</pre>
 `8` |  | Numeric Literal | <code></code> | The number 8 | <pre>8</pre>
 `9` |  | Numeric Literal | <code></code> | The number 9 | <pre>9</pre>
 `[` |  | Ternary Statement | <code>? ?-></code> | Open a ternary statement. Pop condition, if truthy, run <ontrue>, else run <onfalse> | <pre>&lt;condition&gt; [&lt;ontrue&gt;\|&lt;onfalse&gt;}</pre>
 `]` |  | Close All Structures | <code>close-all end-all</code> | Match and close all open structures. | <pre>&lt;structure openers&gt;] &lt;code not in structure&gt;</pre>
 `k` |  | Constant Digraphs | <code></code> | Used for constant-related digraphs | <pre>k&lt;character&gt;</pre>
 `{` |  | While Loop | <code>while while<</code> | Open a while loop. While the top of the stack is truthy, execute code. | <pre>{&lt;condition&gt;\|&lt;code&gt;}</pre>
 `\|` |  | Structure Branch | <code>: -> else: else elif else-if body do branch then in using no? => from</code> | Delimit the next section in a structure. | <pre>&lt;structure open&gt; &lt;code&gt; \| &lt;code&gt; ...</pre>
 `}` |  | Close A Structure | <code>end endfor end-for endwhile end-while endlambda end-lambda end</code> | Match and close the nearest open structure. | <pre>&lt;structure open&gt; &lt;code&gt; } &lt;code not in structure&gt;</pre>
 `~` |  | Two Byte Number | <code></code> | Push the next two bytes as a number, converted from bijective base 255 using the codepage | <pre>~&lt;character&gt;&lt;character&gt;</pre>
 `·∏å` | `#,D` | Open Decision Problem Structure | <code>exists<</code> | Open a decision problem structure. Returns whether an iterable has any items that match a predicate | <pre>·∏å&lt;predicate&gt;\|&lt;container&gt; }</pre>
 `·πÜ` | `#,N` | Generator Structure | <code>relation< generate< generate-from<</code> | Open a generator structure. Allows for generator expressions | <pre>·πÜ&lt;code&gt;\|&lt;initial vector&gt;}</pre>
 `Œª` | `#.{` | Open Lambda | <code>lam lambda {</code> | Open a lambda. | <pre>Œª&lt;parameters&gt;\|&lt;code&gt;}</pre>
 `∆õ` | `#.[` | Open Map Lambda | <code>map-lam map< map-lambda</code> | Open a lambda that automatically maps its function to the top of the stack | <pre>∆õ&lt;code&gt;}</pre>
 `Œ©` | `#.(` | Open Filter Lambda | <code>filter-lam filter< filter-lambda</code> | Open a lambda that automatically filters the top of the stack by its function | <pre>Œ©&lt;code&gt;}</pre>
 `‚Ç≥` | `#,{` | Open Reduce/Accumulate Lambda | <code>reduce-lam reduce< reduce-lambda fold< fold-lam fold-lambda</code> | Open a lambda that automatically reduces/accumulates the top of the stack by its function | <pre>‚Ç≥&lt;code&gt;}</pre>
 `¬µ` | `#,(` | Open Sort Lambda | <code>sort-lam sort< sort-lambda</code> | Open a lambda that automatically sorts the top of the stack by its function | <pre>¬µ&lt;code&gt;}</pre>
 `¬§` | `#.@` | Context Paramter Index | <code>`n`</code> | Index into the list of context parameters. | <pre>¬§&lt;number&gt;</pre>
 `ƒ±` | `#.i` | Imaginary Number | <code>i</code> | Used to represent the imaginary unit | <pre>&lt;real&gt;ƒ±&lt;imaginary&gt;</pre>
 `‚Äû` | `#,"` | Base-252 Compressed String | <code></code> | Decompress and push a string, converted from a bijective base 252 number using the codepage | <pre>"&lt;compressed string&gt;‚Äû</pre>
 `‚Äù` | `#^'` | Dictionary Compressed String | <code></code> | Decompress and push a string using SSS compression, shamelessly stolen from Jelly | <pre>"&lt;compressed string&gt;‚Äù</pre>
 `‚Äú` | `#^"` | Base-252 Compressed Number | <code></code> | Decompress and push a number, converted from a bijective base 252 number using the codepage | <pre>"&lt;compressed number&gt;‚Äú</pre>
 `#:[` |  | Variable Unpacking | <code>:=[</code> | Unpack the top of the stack into a list of variables. | <pre>#:[&lt;var&gt;\|&lt;var&gt;\|&lt;var&gt;]</pre>
 `#:\\`` |  | Defined Modifier Call | <code>$:</code> | Call a defined modifier | <pre>#:`&lt;name&gt;</pre>
 `#:@` |  | Defined Element Call | <code>$@</code> | Call a defined element | <pre>#:@&lt;name&gt;</pre>
 `#:R` |  | Record Definition | <code>record</code> | Define a record with members | <pre>#:R&lt;name&gt;\|#$restricted #=private #!public}</pre>
 `#::` |  | Element/Modifier Definition | <code>define</code> | Define a custom element/modifier that can be used in programs | <pre>#::&lt;mode&gt;&lt;name&gt;\|&lt;arg&gt;\|&lt;arg&gt;...\|&lt;code&gt;}</pre>
 `#:~` |  | Retrieve Original Element | <code>$.</code> | Call the original, vyxal defined, meaning of an element. Useful for when you want to define a new element with the same name as a built-in one | <pre>#:~&lt;name&gt;</pre>
 `#:>>` |  | Extension Method | <code>extension</code> | Define an overload on a custom element based on types. Requires at least one type to be specified. | <pre>#:&gt;&gt;&lt;name&gt;\|&lt;arg1&gt;\|&lt;type1&gt;\|&lt;arg2&gt;\|&lt;type2&gt;...\|&lt;impl&gt;}</pre>
 `#` |  | Miscellaneous Digraphs | <code></code> | Used for miscellaneous digraphs | <pre>#&lt;character&gt;</pre>
 `##` |  | Comment | <code></code> | Comment out the rest of the line | <pre>##&lt;comment&gt;</pre>
 `#$` |  | Retrieve Variable | <code>$</code> | Push the value of a variable. | <pre>#$&lt;variable&gt;</pre>
 `#=` |  | Assign Variable | <code>:=</code> | Assign a variable to a value. | <pre>#=&lt;variable&gt;</pre>
 `#>` |  | Augmented Assignment | <code>:></code> | Apply a function to a variable value and store the result in the same variable. | <pre>&lt;function&gt; #&gt; &lt;variable&gt;</pre>
 `#[` |  | Open List | <code>[</code> | Open a list. Pushes the list to the stack when closed. | <pre>#[item\|item\|item#]</pre>
 `#]` |  | Close List | <code>]</code> | Close a list. Pushes the list to the stack when closed. | <pre>#[item\|item\|item#]</pre>
 `#{` |  | If/Elif/Else Statement | <code>if</code> | Open an if statement. Allows for if/elif/else statements | <pre>#{&lt;if condition&gt;\|&lt;code&gt;\|&lt;else if condition&gt;\|&lt;code&gt;\|&lt;else code&gt;}</pre>
 `‚àÜ` | `#.\` | Mathematical Digraphs | <code></code> | Used for math-related digraphs | <pre>‚àÜ&lt;character&gt;</pre>
 `√∏` | `#,/` | String Digraphs | <code></code> | Used for string-related digraphs | <pre>√∏&lt;character&gt;</pre>
 `√û` | `#.)` | List Digraphs | <code></code> | Used for list-related digraphs | <pre>√û&lt;character&gt;</pre>
